# 02-可变数组

## 一 可变数组概念

可变数组是指数组长度可以随着插入数据的增多、减少发生对应变化的数据结构。

注意：C 语言中的动态数组并不是可变数组，只是其数组长度可以在运行时确定，而不是可以随时”改变“。

可变数组实现方式：

- 1）可变数组结构内部维护一个真实数组，用来存储数据；

- 2）插入数据时，如果超过内部数组容量，则重新申请一个新的更大的数组，将原有数据拷贝到新数组，继续执行插入即可，这称为 **扩容**；

- 3）删除数据时，如果内部数组元素变得很少，可以重新申请一个新的更小的数组，将原有数据拷贝到新数组中，这称呼为 **缩容**。

## 二 扩容缩容机制

如果扩容和缩容的时机设计不当，则会引起 `复杂度震荡`。比如在某个结点进行添加数据时需要扩容，而下次操作则是删除该结点，则正好执行缩容，反复增加删除增加删除，那么其时间复杂度会一直维持在最高水平。

复杂度震荡的解决办法：扩容的倍数缩容的时机相乘不等于 1 即可。

还有一些引擎如 V8，会使用均摊方式进行扩容缩容。比如设定数组容量为 5：`cap = 5`，那么在长度到 5 时，就需要一次扩容，
扩容时就需要移动 5 个数据，这样就会造成插入数据时，因为要扩容会造成该次插入耗时比平时状态更长！。为了避免数组的某次增
减、删除元素操作突然耗时较长，可以进行均摊，比如每次插入元素，都将`cap + 1`。

## 三 可变数组特性

可变数组其特点、复杂度与数组没有本质区别，因为其底层也是维护着一个数组，只不过用户可以无视其容量进行数据数目变更。

## 四 可变数组实现贴士

### 4.1 Golang 中的 Slice

Golang 官方为了解决数组长度不能扩展，以及基本类型数组传递时产生副本的问题，官方包中引入了专有的数据结构：切片 Slice。Slice 使用方式如下：

```go
    // 常用创建方式：
    var s1 []int    // 和声明没有长度的数组一样，但是无意义，因为底层的数组指针为nil
    s2 := []byte {'a','b','c'}
    fmt.Println(s1)    //输出 []
    fmt.Print(s2)    //输出 [97 98 99]

    // 使用 make 函数创建：
    slice1 := make([]int,5)  // 创建长度为5，容量为5，初始值为0的切片
    slice2 := make([]int,5,7) // 创建长度为5，容量为7，初始值为0的切片
    slice3 := []int{1,2,3,4,5} // 创建长度为5，容量为5，并已经初始化的切片
```

### 4.2 Java 中的数组

JS 的数组本身就具备可变性，实际业务中完全没有手动实现可变数组的必要。

### 4.3 Java 中的可变数组

Java 中的对象 ArrayList 用法类似可变数组。
