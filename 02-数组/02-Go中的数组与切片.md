## 一 Go中的数组

### 1.1 数组的声明

同大多语言的数组一样，Go的数组长度定义后不可更改，长度使用 len() 获取。  

```go
var arr1 [10]int					//定义长度为10的整型数组，很少这样使用
arr2 [5]int := [5]int{1,2,3,4,5}	//定义并初始化
arr3 := [5]int{1,2,3,4,5}			//自动推导并初始化
arr4 := [5]int{1,2}					//指定总长度，前几位被初始化，没有的使用零值
arr5 := [5]int{2:10, 4:11}			//有选择的初始化，没被初始化的使用零值
arr6 := [...]int{2,3,4}				//自动计算长度
```

### 1.2 数组元素获取

```
arr[:]      代表所有元素
arr[:5]     代表前五个元素，即区间的左闭右开
arr[5:]     代表从第5个开始（不包含第5个）
len(arr)    数组的长度
```
贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型切片

### 1.3 数组的遍历

方式一：for循环遍历
```go
arr := [3]int{1,2,3}

for i := 0; i < len(arr); i++ {
	fmt.Println(arr[i])
}
```

方式二：for-range遍历
```go
arr := [3]int{1,2,3}

for k, v := range arr {
	fmt.Println(k)	//元素位置	
	fmt.Println(v)	//元素值
}
```

### 1.4 数组使用注意事项

数组创建完长度就固定，不可以再追加元素；长度是数组类型的一部分，因此`[3]int`与`[4]int`是不同的类型；数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。  

## 二 Go中的专有数据结构-切片

### 2.1 Golang中的切片

为了解决数组长度不能扩展，以及基本类型数组传递时产生副本的问题，Go引入了专有的数据结构切片（Slice）。  

常用创建方式：
```go
var s1 []int				// 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil
s2 := []byte {'a','b','c'}
fmt.Println(s1)				//输出 []
fmt.Print(s2)				//输出 [97 98 99]
```

使用make函数创建：
```go
slice1 := make([]int,5)		// 创建长度为5，容量为5，初始值为0的切片
slice2 := make([]int,5,7)	// 创建长度为5，容量为7，初始值为0的切片
slice3 := []int{1,2,3,4,5}	// 创建长度为5，容量为5，并已经初始化的切片
```

从数组创建：  
slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i:

#### 2.2 切片常见内置函数

切片常用内置函数：
```
len()			            返回切片长度，即当前元素的个数
cap()			            返回切片底层数组容量
append()		            对切片追加元素
copy(dst, src []Type) int   将src中数据拷贝到dst中，返回拷贝的元素个数
```

#### 2.3 切片的一些简便操作  

- slice的默认开始位置是0，arr[:n]等价于arr[0:n]
- slice的第二个序列默认是数组的长度，arr[n:]等价于arr[n:len(ar)]
- 如果从一个数组里面直接获取slice，可以这样arr[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于arr[0:len(ar)]
- 切片的遍历可以使用for循环，也可以使用range函数  

#### 2.4 字符串转切片  

```go
str := "hello,世界"
a := []byte(str)		//字符串转换为[]byte类型切片
b := []rune(str)		//字符串转换为[]rune类型切片
```

## 三 切片存储结构

与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示：
```go
type slice struct {
	arrary = unsafe.Pointer		//指向底层数组的指针
	len int						//切片元素数量
	cap int						//底层数组的容量
}
```

所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。  

合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。  

贴士：为了方便，笔者在以后大多场景中，都使用切片来代替数组来模拟数据结构与算法。   