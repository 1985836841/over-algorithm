# 02-动态数组

## 一 动态数组简介

在早期的语言中（比如 C 语言），数组并不支持在运行期间改变大小，必须预定义数组的容量。数组长度的固定在使用上有极大约束力，如果数组的长度可以在适当的时机进行扩容、缩容，则是实际开发中所青睐的数据结构。

一些近代语言如 Java,JS 是支持数组的动态定义的，即长度可变，所以数组可以分为：

- 静态数组：编译时确定数组的长度，为了防止空间不足，所以尽量将数组的长度定义的大点，但是容易造成内存浪费
- 动态数组：不需要在编译时确定长度，而是在运行过程中确定。

动态数组的实现仍然是利用了静态数组，当数组容量不够时，进行扩容，当数组容量过大时，进行缩容，其本质是重新申请了一个数组内存，将原有的数据拷贝入新申请的数组。

## 二 动态数组的表示

```c++
#define MaxSize 5               // 默认容量，取小值便于测试
typedef int ElemType;           // 数据元素类型

// 动态数组结构体
typedef struct {                // 定义的类型
    // ElemType data[MaxSize];  // 静态分配方式，即定义时已经确定了数组空间（长度）
    ElemType    *data;          // 动态数组数据元素存储地址，动态分配方式
    int         capacity;       // 动态数组容量
    int         length;         // 当前数组长度
} DynamicArray;                 // 给该类型起的名字

// 这里只制作简单的制作几个基础函数
DynamicArray newDynamicArray(); // 构造函数
void pushElem(&A, e);           // 向最后一位增加元素
void popElem(&A);               // 移除最后一位元素
ElemType indexElem(int);        // 获取索引位置元素
void destroy(&A);               // 数组是否为空
void display(&A);               // 显示数组数据
int capacity(&A);               // 获取容量
int length(&A);                 // 获取长度
```

## 三 扩容缩容机制

如果扩容和缩容的时机设计不当，则会引起 `复杂度震荡`。比如在某个节点进行添加数据时需要扩容，而下次操作则是删除该节点，则正好执行缩容，反复增加删除增加删除，那么其时间复杂度会一直维持在最高水平。

复杂度震荡的解决办法：扩容的倍数缩容的时机相乘不等于 1 即可。

还有一些引擎如 V8，会使用均摊方式进行扩容缩容。比如设定数组容量为 5：`cap = 5`，那么在长度到 5 时，就需要一次扩容，扩容时就需要移动 5 个数据，这样就会造成插入数据时，因为要扩容会造成该次插入耗时比平时状态更长！。为了避免数组的某次增减、删除元素操作突然耗时较长，可以进行均摊，比如每次插入元素，都将`cap + 1`。

## 四 动态数组的实现

### 4.1 动态数组 C 语言实现

C 语言没有提供原生的动态数组，需要手动实现：

```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 5               // 默认容量，取小值便于测试
typedef int ElemType;           // 数据元素类型

// 动态数组结构体
typedef struct {                // 定义的类型
    // ElemType data[MaxSize];  // 静态分配方式，即定义时已经确定了数组空间（长度）
    ElemType    *data;          // 动态数组数据元素存储地址，动态分配方式
    int         capacity;       // 动态数组容量
    int         length;         // 当前数组长度
} DynamicArray;                 // 给该类型起的名字

// 构造空动态数组
DynamicArray newDynamicArray(){
    // 申请内存
    DynamicArray *A = malloc(sizeof(DynamicArray));
    A->data = (ElemType *)malloc(MaxSize * sizeof(ElemType));

    // 修正属性
    A->capacity = MaxSize;
    A->length = 0;

    return *A;
}

// 扩容工具：注意该函数放置顺序
void expandCap(DynamicArray *A){
    if(A->length == A->capacity){
        // 执行扩容：扩充为原容量的二倍
        int newCap = A->capacity * 2;

        // 申请新数组空间，并拷贝数据：使用最原始的for循环，尽量简单易理解
        // realloc 方式：(ElemType *)realloc(A->data, newCap * sizeof(ElemType));
        ElemType *newData = malloc(newCap * sizeof(ElemType));
        for(int i = 0; i < A->length; i++){
            newData[i] = A->data[i];
        }
        free(A->data);
        A->data = newData;

        // 变更新容量
        A->capacity = newCap;
    }
}

// 缩容工具：注意该函数放置顺序，数组元素为当前容量的 1/4，缩容为当前容量的一半
void reduceCap(DynamicArray *A){
    if(A->length <= A->capacity / 4){
        int newCap = A->capacity / 2;

        // 缩容
        ElemType *newData = malloc(newCap * sizeof(ElemType));
        for(int i = 0; i < A->length; i++){
            newData[i] = A->data[i];
        }
        free(A->data);
        A->data = newData;

        // 变更新容量
        A->capacity = newCap;
    }
}

// 增：增加最后一位
void pushElem(DynamicArray *A, ElemType e){
    if(A->data == NULL){
        printf("数组不存在\n");
    } else {
        expandCap(A);
        A->length++;
        A->data[A->length - 1] = e;
    }
}

// 删:移除最后一位
void popElem(DynamicArray *A){
    if(A->length == 0){
        printf("数组元素个数为0\n");
    } else {
        reduceCap(A);
        A->length--;
    }
}

// 查：根据索引获取数据
ElemType indexElem(DynamicArray *A, int index){
    if(index < 0 || index > A->length - 1){
        printf("数组索引越界\n");
        return (ElemType)0;
    } else {
        return A->data[index];
    }
}

// 获取容量：
int capacity(DynamicArray *A){
    return A->capacity;
}

// 获取长度：
int length(DynamicArray *A){
    return A->length;
}

// 清空
void clear(DynamicArray *A){
    A->length = 0;
}

// 销毁
void destroy(DynamicArray *A){
    if(A->data != NULL){
        free(A->data);
    }
}
```

### 4.2 动态数组 Go 语言实现

Golang 官方为了解决数组长度不能扩展，以及基本类型数组传递时产生副本的问题，官方包中引入了专有的数据结构切片 Slice，使用方式如下：

```go
    // 常用创建方式：
    var s1 []int    // 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil
    s2 := []byte {'a','b','c'}
    fmt.Println(s1)    //输出 []
    fmt.Print(s2)    //输出 [97 98 99]

    // 使用 make 函数创建：
    slice1 := make([]int,5)  // 创建长度为5，容量为5，初始值为0的切片
    slice2 := make([]int,5,7) // 创建长度为5，容量为7，初始值为0的切片
    slice3 := []int{1,2,3,4,5} // 创建长度为5，容量为5，并已经初始化的切片
```

手动实现一个基础动态数组：

```go
import "fmt"

const MaxSize = 5 // 默认容量，取小值便于测试

type DynamicArray struct {
 data     []interface{} // 动态数组内的真实数组
 capacity int           // 动态数组容量
 length   int           // 动态数组元素个数
}

// 创建动态数组对象
func NewDynamicArray() *DynamicArray {
 return &DynamicArray{
  data:     make([]interface{}, MaxSize),
  capacity: MaxSize,
  length:   0,
 }
}

// 扩容方法：超过数组容量，按照当前容量的 2 倍扩容
func (arr *DynamicArray) expandCap() {
 if arr.length == arr.capacity {
  // 拷贝数据
  newCap := arr.capacity * 2
  newData := make([]interface{}, newCap)
  for i := 0; i < arr.length; i++ {
   newData[i] = arr.data[i]
  }
  arr.data = newData

  // 变更容量
  arr.capacity = newCap
 }
}

// 缩容方法：数组元素为当前容量的 1/4，缩容为当前容量的一半
func (arr *DynamicArray) reduceCap() {
 if arr.length <= arr.capacity/4 {

  newCap := arr.capacity / 2
  newData := make([]interface{}, newCap)
  for i := 0; i < arr.length; i++ {
   newData[i] = arr.data[i]
  }
  arr.data = newData

  // 变更新容量
  arr.capacity = newCap
 }
}

// 增：增加最后一位
func (arr *DynamicArray) PushElem(e interface{}) {
 if arr.data == nil {
  fmt.Println("数组不存在")
  return
 }

 arr.expandCap() // 扩容
 arr.length++
 arr.data[arr.length-1] = e
}

// 删:移除最后一位
func (arr *DynamicArray) PopElem() {
 if arr.length == 0 {
  fmt.Println("数组元素个数为0")
  return
 }

 arr.reduceCap() // 缩容
 arr.length--
}

// 查：根据索引获取数据
func (arr *DynamicArray) IndexElem(index int) interface{} {
 if index < 0 || index > arr.length-1 {
  fmt.Println("数组索引越界")
  return nil
 }
 return arr.data[index]
}

// 获取容量
func (arr *DynamicArray) Capacity() int {
 return arr.capacity
}

// 获取长度
func (arr *DynamicArray) Length() int {
 return arr.length
}

// 销毁：Go语言自动内存管理，无需该方法

// 显示动态数组数据
func (arr *DynamicArray) Display() {
 fmt.Println(arr.data[0:arr.length])
}
```

### 4.3 动态数组 JavaScript 实现

JS 的数组本身就具备动态性，没有实现动态数组的必要。不过 JS 数组的底层实现较为复杂，甚至会演变为哈希表，在 ![over-javascript](https://github.com/overnote/over-javascript)专门讲解。
