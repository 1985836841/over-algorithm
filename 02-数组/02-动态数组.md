## 一 动态数组扩容与缩容机制

数组的长度固定在使用上有极大约束力，如果数组的长度可以在适当的时机进行扩容、缩容，则是实际开发中所青睐的数据结构。  

扩容/缩容的本质：重新申请了一个数组内存，将原有的数据拷贝入新申请的数组。  

在制作数据结构的时候，比如size=5，那么在长度到5时，就需要一次扩容，那么本次操作肯定比较耗时，为了避免某次操作突然耗时较长，可以进行均摊，比如每次插入元素，都将size+1，v8具备这样的扩容缩容机制。  

缩容设计：下列只是一个例子
```
# length：数组中实际元素个数    size：数组的容量
    if size <= length / 2  &&  size > defaultSize {
            // 进行缩容
    }   
```

但是扩容和缩容设计不当，则会引起复杂度震荡。比如在某个节点进行添加收，需要扩容，而下次操作则是删除该节点，则执行缩容，反复增加删除增加删除，那么其时间复杂度会一直维持在最高水平。  

解决办法：扩容的倍数缩容的时机相乘不等于1即可  


## 二 Go中的专有数据结构-切片

### 2.1 Golang中的切片

为了解决数组长度不能扩展，以及基本类型数组传递时产生副本的问题，Go引入了专有的数据结构切片（Slice）。  

常用创建方式：
```go
var s1 []int				// 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nil
s2 := []byte {'a','b','c'}
fmt.Println(s1)				//输出 []
fmt.Print(s2)				//输出 [97 98 99]
```

使用make函数创建：
```go
slice1 := make([]int,5)		// 创建长度为5，容量为5，初始值为0的切片
slice2 := make([]int,5,7)	// 创建长度为5，容量为7，初始值为0的切片
slice3 := []int{1,2,3,4,5}	// 创建长度为5，容量为5，并已经初始化的切片
```

从数组创建：  
slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i:

#### 2.2 切片常见内置函数

切片常用内置函数：
```
len()			            返回切片长度，即当前元素的个数
cap()			            返回切片底层数组容量
append()		            对切片追加元素
copy(dst, src []Type) int   将src中数据拷贝到dst中，返回拷贝的元素个数
```

#### 2.3 切片的一些简便操作  

- slice的默认开始位置是0，arr[:n]等价于arr[0:n]
- slice的第二个序列默认是数组的长度，arr[n:]等价于arr[n:len(ar)]
- 如果从一个数组里面直接获取slice，可以这样arr[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于arr[0:len(ar)]
- 切片的遍历可以使用for循环，也可以使用range函数  

#### 2.4 字符串转切片  

```go
str := "hello,世界"
a := []byte(str)		//字符串转换为[]byte类型切片
b := []rune(str)		//字符串转换为[]rune类型切片
```

## 三 切片存储结构

与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示：
```go
type slice struct {
	arrary = unsafe.Pointer		//指向底层数组的指针
	len int						//切片元素数量
	cap int						//底层数组的容量
}
```

所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。  

合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。  

贴士：为了方便，笔者在以后大多场景中，都使用切片来代替数组来模拟数据结构与算法。  