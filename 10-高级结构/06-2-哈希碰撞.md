## 一 碰撞问题

碰撞问题即：哈希化后的索引值处已经有数据存在了，无法用于存储。哈希碰撞也称为哈希冲突（Hash Collision）。  

## 二 碰撞问题解决方案一

### 2.1 方案一 链地址法

> 链地址法（Separate Chaining）：哈希表中的数组元素是一个容器（链表/数组），容器中存储了所有最后哈希化后同一个索引的数据

Java8采用该方式，其数组的每个节点是个单向链表，但是在添加元素时，这个单向链表可能会因为一些情况转为红黑树，比如：
- 桶的容量 >= 64，且单向链表的节点数量大于8时
- 当红黑树的节点数量少到一定程度时，又会转为单向链表


### 2.2 方案二 开放地址法

> 开放地址法（Open Addressing）：发生冲突后，寻找哈希表中空的散列地址存放，只要哈希表足够大，那么空的散列地址一定能找到

假设有关键字合集：{12,67,56,16,25,37,22,29,15,47,48,34}，表长为12，使用散列函数 `f(key)=key mod 12` 计算索引地址，当计算到37时，会发现与计算25得到的结果都是1，则此时就需要为37寻找新的地址。寻找办法是按照这个公式再次查找 `f(37) = (f(37) + 1) mod 12`，值为2，则将37存入下标为2的位置。依次类推。  

上述的解决方案称为**线性探测**。但是这里还会产生新的问题：在不断+1过程中遇到的位置都不是空位，即是一连串的填充单元！这种现象叫做聚集。聚集引发了严重的性能问题。  

针对聚集现象，我们想到的办法自然是优化探测的步长，以减少聚集的机会，例如：第一次探测index+$1^2$，第二次探测index+$2^2$。此种做法我们称为**二次探测**。  

即使是二次探测，也依然会有问题，比如，连续插入的是32-112-82-2-192这样的数据，其累加时步长是相同的，也会造成步长不一样的聚集。  

聚集的最终解决方案是**再哈希（Re-Hashing）**，再哈希法是为了彻底消除聚集问题的方案：
- 二次探测的步长是固定的：1，4，9，16....
- 现在使用一种依赖关键字的探测序列，每个关键字都不一样。那么及时不同的关键字映射到了相同的数组下标，其使用的探测序列也不相同

从上看出，再哈希法其实就是把关键字使用另外一个哈希函数，获得的结果作为步长。 

贴士：
- 再哈希函数其结果不能输出为0，因为没有步长则探测变成了原地踏步。
- 再哈希函数也不能和之前的哈希函数一样，因为如果使用一样的哈希函数，其结果还是原来的位置

再哈希函数一般如下表示：
```
# stepSize 即步长。 constant是一个小于数组容量的质数
stepSize = constant - (key % constant)      
```

贴士：利用线性探测时，删除元素操作切记不能将元素设置为空，因为下次探测会遇到空指针，推荐设置为类似-1这样的不可能的值。  

### 2.3 方案三 公共溢出区法

> 公共溢出区法：只要是冲突的数据都放置在一个额外的地方存储，即设置一个与当前哈希表结构一样的溢出表，专门用于存储对应溢出数据

在查找时， 对给定值通过散列函数计算出散列地址后， 先与基本表的相应位置进行比对， 如果相等， 则查找成功； 如果不相等， 则到溢出表去进行顺序查找。 如果相对于基本表而言， 有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。


## 三 哈希表效率分析

### 3.1 开放地址法

哈希表中执行插入和查询的效率是很高的：
- 如果没有产生冲突，那么性能极高
- 如果发生冲突，存取时间依赖于探测长度。
  - 链地址法：发生冲突后取决于数组索引中对应链表的长度
  - 开放地址法：发生冲突后取决于探测的长度

平均探测长度取决于装填因子，装填因子越大，探测长度也越大：
```
装填因子 = 总数据项 / 哈希表长度
```

由上述公式得知，开放地址法，其装填因子最大值也只能是1，但是链地址法的个数是不确定的。 

探测序列P和装填因子L的关系：
- 查找成功：P = (1 + 1 / (1 - L)$^2$) / 2
- 查找失败：P = (1 + 1 / (1 - L)) / 2

总结：
- 装填因子是1/2时，成功的搜索需要1.5次比较，不成功的搜索需要2.5次
- 装填因子是2/3时，分别需要2.0次和5.0次比较
- 如果装填因子更大，则比较次数会非常大
- 应该使装填因子保持在2/3以下，最好在1/2以下。但是装填因子越低，给定数量的数据项会需要越多的空间
- 实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，速度上升

二次探测和再哈希法性能相当，比线性探测性能略好：
- 成功搜索：-log<sub>2</sub>(1-loadFactor)/loadFactor
- 搜索失败：1/(1-loadFactor)

总结：
- 当填充因子是0.5时，成功和不成功的查找平均需要2次比较
- 当填充因子是2/3时，分别需要2.37和3.0次比较
- 当填充因子是0.8时，分别需要2.9和5.0次
- 因此对于较高的填充因子，相比线性探测，二次探测和再哈希法是可以忍受的

### 3.2 链地址法

链地址法比开放地址法实现简单：
- 加入哈希表有length个数据项，每个数据项都有一个链表，所有链表共有n个数据项
- 则平均数据项数目为：n/length  其实该值就是填充因子

总结：
- 成功可能只需要查找链表的一半： 1+loadFactor/2
- 失败可能需要查找整个链表：1+loadFactor

相对而言，链地址法效率好于开放地址法，实际开发中，哈希表也大多使用链地址法实现（比如Java语言内置的HashMap）。因为链地址法不会因为添加了某元素后性能急剧下降。