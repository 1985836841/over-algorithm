## 一 算法

算法（algorithm）是对特定问题求解步骤的一种描述，在计算机中是指令的有限序列，具备以下5个特性：
- 输入：可以理解为参数，所以算法可以没有输入，也可以有多个输入
- 输出：算法必须有输出，没有输出，算法也就失去了意义。但是算法也可以有0个输入，表示算法本身确定了初识条件
- 有穷性：算法运算完毕后必须结束，其步骤必须是有限的
- 确定性：算法的每个步骤都有明确的意义，在一定条件下，相同的输入只能有唯一结果
- 可行性/有效性：算法的每一步都必须是可行有效的，即每一步都能通过执行有限次数完成

一个算法如果要设计好，必须达到以下目标：
- 正确性（correctness）：不含语法错误，对各种需求的输入数据都能满足
- 可读性（readability）：算法程序应该简洁易懂
- 健壮性（robustness）：非法数据被输入时，不会引起算法崩溃、出错
- 效率与低存储量需求：算法要尽量优秀，即：执行时间短，占据内存小！

**算法的原地工作**：一个可执行程序除了需要内存空间外，如果还需要额外的空间，若该额外空间相对于问题的规模来说是个常数，那么称之为原地工作！  

## 二 函数的渐进增长

现在实现一个结果有两个算法：算法A与算法B，他们的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作，两个算法谁更快？  

我们发现，一开始A算法计算次数很多，随着n的增长(大于2)，A算法计算次数比算法B越来越少。所以可以得出结论：算法A整体上比算法B好。  

输入规模 n 在没有限制的情况下，只要超过一个数值 N ，这个函数就总大于另一个函数，则称函数是渐进增长：
```
函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得所有的n>N,f(n)总是比g(n)大，那么f(n)的增长渐进快于g(n)。    
```

在很多算法中，随着n的增长，常熟的影响会越来越小，最高项的指数影响越来越大，所以判断一个算法的规律时，更应该关注最高项的阶数。  

## 三 算法的时间复杂度

算法中，语句的总执行次数使用T(n)表示，即表示问题规模n的函数：
```
    T(n)= O(f(n))
```

随着n的增长，算法执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称**时间复杂度**。这样用O()来体现算法时间复杂度的记法，也称为**大O表示法**。

> 一般情况下，T(n)增长最慢的算法为最优算法。  

程序中语句的重复执行的次数称为**频度**（frequency count），频度直接影响了算法的时间复杂度。示例：
```c
// 示例一
{
    x++; 
    s = 0;
}

// 示例二
for(i = 1; i <= n; i++){
    x++; 
    s += x;
}

// 示例三
for(i = 1; i <= n; i++){
    for ( j = 1; j <=n; j++) {
        x++; 
        s += x;
    }
}
```

含有 `x加一` 的语句的频度分别为1，n，n<sup>2</sup>，那么他们的时间复杂度就分别为O(1)，O(n)，O(n<sup>2</sup>)。

**最坏情况与平均情况**：   
比如查询n个随机数数组中最小数，最好第一个元素就是，那么时间复杂度为O(1)，如果很不幸数组的最后一个元素才是，那么时间复杂度是O(n)。   

所以算法的时间复杂度具体会受到2个因素影响：
- 问题的规模：规模（n）越大，算法的基本操作执行的次数越多
- 待处理数据的初态：如两个数相称，如果有一个因子为0，那么算法的时间复杂度立刻就变为了O(1)

对算法的分析有两种方法：
- 计算所有情况的平均值，称为平均时间复杂度(上述案例的n/2)
- 计算最坏情况下的复杂度，**一般都会使用最坏复杂度**  


## 四 算法的空间复杂度

通过空间能够换取时间上的便利，比如判断某个年份是否是闰年，我们可以书写一个算法，这个算法每次给出年份都要进行计算，但是我们也可以将所有的年份书写为一个键值对，是闰年的值为1，不是的值为0，这样判断是否是闰年直接查看键值对结果即可，但是相应的，我们需要这个键值对的额外存储空间。  

算法的空间复杂度（space complexity）公式：
```
S(n) = O(f(n))      # n为问题规模，f(n)为n锁占存储空间的函数
```

贴士：如果算法执行时所需的辅助空间相遇于输入的数据量来说是个常数，那么称此算法为原地工作，空间复杂度为O(1)。  

**通常我们说算法的复杂度是指时间复杂度**。 