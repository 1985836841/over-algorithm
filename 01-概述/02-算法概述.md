# 02-算法概述

## 一 算法概念

### 1.1 什么是算法

> 算法（algorithm）是对特定问题求解步骤的一种描述。

比如现在要计算 1 到 n 之间的整数的和，这个求和函数其实就是一个算法了，当然不同的算法，其效率在不同场景中往往有好坏之分：

```c++
// 第一种算法
int sum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}

// 第二种算法：数学家高斯孩提时的做法
int sumByGauss(int n) {
    int sum = n * (n + 1) / 2;
    return sum;
}
```

当然我们不能仅仅从代码的数量上就判定高斯的做法更加优秀，而是要通过运算步骤数量来判定，假如现在要运算 1 到 100 之间的整数和，第一种算法 for 循环中的加法运算执行了 100 次，而高斯的算法无论 n 取值为多少，只是进行了乘法、加法、除法这三步运算即得到了结果，n 越大，高斯的算法越发优秀！

### 1.2 算法的特性

**在计算机中是指令的有限序列**，每条指令表示一个或者多个操作。算法具备以下 5 个基本特性：

```txt
输入：可以理解为参数，所以算法可以没有输入，也可以有多个输入
输出：算法必须有输出，没有输出，算法也就失去了意义
有穷性：算法运算的步骤（指令）必须是有限次的，算法无法停止运行同样失去了意义
确定性：算法的每个步骤都必须有明确的意义，在一定条件下，相同的输入只能有唯一结果
可行性：算法的每个步骤都必须是可行有效的，即每一步都能通过执行有限次数完成
```

### 1.3 算法的设计要求

一个算法如果要设计好，必须达到以下目标：

```txt
正确性（correctness）：不含语法错误，对各种合法的输入数据都能满足
可读性（readability）：算法程序应该简洁易懂
健壮性（robustness）：非法数据被输入时，不会引起算法崩溃、出错，也即鲁棒性
效率与低存储量需求：算法的执行时间要尽量短，占据内存要尽量小
```

## 二 算法的度量

### 2.0 算法的执行次数

程序的执行时间是无法准确预估的，可以通过预估代码基本操作的执行次数来判断算法的效率。

规模为 $n$ 的问题，所需要的时间可以记为 $T(n)$，在代码中，语句的总执行次数为：

$T(n)= O(f(n))$

如下示例中，算法的执行规模是 n，执行次数是：$T(n) = 3n + 1$。

```c++
void fn(int n) {
    for (int i = 0; i < n; i++) {
        printf("开始本轮输出\n");  // 这里执行 1 * n 次
        printf("%d\n", i);         // 这里执行 1 * n 次
        printf("本轮输出结束\n");  // 这里执行 1 * n 次
    }
    printf("跳出循环，本轮程序运行结束\n");  // 这里执行 1 次
}
```

在上述描述中，通过代码的基本执行次数粗略了估算了算法的效率，但是算法的效率还需要带入规模的差异。现在实现一个结果有两个算法：算法 A 与算法 B，他们的输入规模都是 n，算法 A 要做 2n+3 次操作，算法 B 要做 3n+1 次操作，两个算法谁更快？

一开始 A 算法计算次数很多，但是随着 n 的增长(大于 2)，A 算法计算次数比算法 B 越来越少，所以算法 A 整体上比算法 B 好。

输入规模 n 在没有限制的情况下，只要超过一个数值 N ，这个函数就总大于另一个函数，则称函数是**渐进增长**：

> 函数的渐进增长：给定两个函数 $f(n)$ 和 $g(n)$，如果存在一个整数 $N$，使得所有的 $n > N$ ,$f(n)$ 总是比 $g(n)$ 大，那么 $f(n)$ 的增长渐进快于 $g(n)$。

在评价算法的效率时，往往忽略其处理小规模问题的差异，而是关注在更大规模问题时的表现，即更注重随着规模的增大，其效率的总体变化趋势。

### 2.1 算法的时间复杂度

> **时间复杂度**：随着问题规模 n 的增长，算法执行时间的增长率和 f(n)的增长率相同，称为算法的渐进时间复杂度，简称时间复杂度。

这样用 $O()$ 来体现算法时间复杂度的记法，也称为**大 $O$ 表示法（big-O notation）**。一般情况下，$T(n)$ 增长最慢的算法为最优算法。程序中语句的重复执行的次数称为**频度**（frequency count），频度直接影响了算法的时间复杂度。

**最坏情况与平均情况**：
比如查询 n 个随机数数组中最小数，最好第一个元素就是，那么时间复杂度为 $O(1)$，如果很不幸数组的最后一个元素才是，那么时间复杂度是 $O(n)$。

所以算法的时间复杂度具体会受到 2 个因素影响：

- 问题的规模：规模 $(n)$ 越大，算法的基本操作执行的次数越多
- 待处理数据的初态：如两个数相称，如果有一个因子为 0，那么算法的时间复杂度立刻就变为了 $O(1)$

对算法的分析有两种方法：

- 计算所有情况的平均值，称为平均时间复杂度(上述案例的 n/2)
- 计算最坏情况下的复杂度，**一般都会使用最坏复杂度**

### 2.2 算法的空间复杂度

通过空间能够换取时间上的便利，比如判断某个年份是否是闰年，我们可以书写一个算法，这个算法每次给出年份都要进行计算，但是我们也可以将所有的年份书写为一个键值对，是闰年的值为 1，不是的值为 0，这样判断是否是闰年直接查看键值对结果即可，但是相应的，我们需要这个键值对的额外存储空间。

算法的空间复杂度（space complexity）公式：

$S(n) = O(f(n))$

$n$ 为问题规模，$f(n)$ 为 $n$ 所占存储空间的函数，同样使用大$O$表示法表示空间复杂度。

空间复杂度有以下几种情形：

- 常量空间 $O(1)$：存储空间固定，与输入的规模无关
- 线性空间 $O(n)$：存储空间是一个线性集合如数组，集合大小与输入规模 n 成正比
- 二维空间 $O(n^2)$：分配的空间是一个二维数组集合，集合的长度、宽度与输入规模 n 成正比
- 递归空间 $O(n)$：计算机在运行递归代码时，会专门分配一块内存，存储方法调用栈，递归越深，入栈元素越多，到达结束条件时，方法出栈。执行递归操作所需要的内存空间和递归的深度成正比，纯粹递归操作的空间复杂度也是线性的，如果递归深度是 $n$，那么其空间复杂度就是 $O(n)$

### 2.3 总结

**通常我们说算法的复杂度是指时间复杂度**，因为在当前时代，对速度的追求往往大于对空间的追求。

如果算法执行时所需的辅助空间相遇于输入的数据量来说是个常数，那么称此算法为**原地工作**。
