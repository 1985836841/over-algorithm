# 02-算法概述

## 一 算法概念

算法（algorithm）是对特定问题求解步骤的一种描述，比如现在要计算 1 到 100 之间的整数的和，这个求和函数其实就是一个算法了，当然不同的算法，其效率不一致。

**在计算机中是指令的有限序列**，具备以下 5 个基本特性：

- **输入**：可以理解为参数，所以算法可以没有输入，也可以有多个输入
- **输出**：算法必须有输出，没有输出，算法也就失去了意义。但是算法也可以有 0 个输入，表示算法本身确定了初识条件
- **有穷性**：算法运算完毕后必须结束，其步骤必须是有限的
- **确定性**：算法的每个步骤都有明确的意义，在一定条件下，相同的输入只能有唯一结果
- **可行性**：算法的每一步都必须是可行有效的，即每一步都能通过执行有限次数完成

一个算法如果要设计好，必须达到以下目标：

- 正确性（correctness）：不含语法错误，对各种需求的输入数据都能满足
- 可读性（readability）：算法程序应该简洁易懂
- 鲁棒性（robustness）：非法数据被输入时，不会引起算法崩溃、出错，即健壮性
- 效率与低存储量需求：算法要尽量优秀，即：执行时间短，占据内存小！

**算法的原地工作**：

```
一个可执行程序除了需要内存空间外，如果还需要额外的空间，若该额外空间相对于问题的规模来说是个常数，那么称之为原地工作！
```

## 二 算法复杂度

### 2.1 算法的执行次数

程序的执行时间是无法准确预估的，可以通过预估代码基本操作的执行次数来判断算法的效率。

规模为 n 的问题，所需要的时间可以记为 `T(n)`，即在代码中，语句的总执行次数使用 T(n)表示：

```
T(n)= O(f(n))
```

如下示例中，算法的执行规模是 n，执行次数是：`T(n) = 3n + 1`。

```go
func fn1(n int){
    for i := 0; i < n; i++ {
        fmt.Println("开始输出")             // 这里执行 1 * n 次
        fmt.Println(i)                  // 这里执行 1 * n 次
        fmt.Println("结束输出")         // 这里执行 1 * n 次
    }
    fmt.Println("跳出循环")             // 这里执行1次
}
```

通过计算算法中代码的基本执行次数可以粗略的估算算法的效率。

### 2.2 函数的渐进增长

现在实现一个结果有两个算法：算法 A 与算法 B，他们的输入规模都是 n，算法 A 要做 2n+3 次操作，算法 B 要做 3n+1 次操作，两个算法谁更快？

一开始 A 算法计算次数很多，但是随着 n 的增长(大于 2)，A 算法计算次数比算法 B 越来越少，所以算法 A 整体上比算法 B 好。

输入规模 n 在没有限制的情况下，只要超过一个数值 N ，这个函数就总大于另一个函数，则称函数是**渐进增长**：

> 函数的渐进增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N，使得所有的 n>N ,f(n) 总是比 g(n) 大，那么 f(n) 的增长渐进快于 g(n)。

在评价算法的效率时，往往忽略其处理小规模问题的差异，而是关注在更大规模问题时的表现，即更注重随着规模的增大，其效率的总体变化趋势。

### 2.2 算法的时间复杂度

> 时间复杂度：随着问题规模 n 的增长，算法执行时间的增长率和 f(n)的增长率相同，称为算法的渐进时间复杂度，简称**时间复杂度**。

这样用 O()来体现算法时间复杂度的记法，也称为**大 O 表示法（big-O notation）**。一般情况下，T(n)增长最慢的算法为最优算法。程序中语句的重复执行的次数称为**频度**（frequency count），频度直接影响了算法的时间复杂度。

**最坏情况与平均情况**：
比如查询 n 个随机数数组中最小数，最好第一个元素就是，那么时间复杂度为 O(1)，如果很不幸数组的最后一个元素才是，那么时间复杂度是 O(n)。

所以算法的时间复杂度具体会受到 2 个因素影响：

- 问题的规模：规模（n）越大，算法的基本操作执行的次数越多
- 待处理数据的初态：如两个数相称，如果有一个因子为 0，那么算法的时间复杂度立刻就变为了 O(1)

对算法的分析有两种方法：

- 计算所有情况的平均值，称为平均时间复杂度(上述案例的 n/2)
- 计算最坏情况下的复杂度，**一般都会使用最坏复杂度**

### 2.3 算法的空间复杂度

通过空间能够换取时间上的便利，比如判断某个年份是否是闰年，我们可以书写一个算法，这个算法每次给出年份都要进行计算，但是我们也可以将所有的年份书写为一个键值对，是闰年的值为 1，不是的值为 0，这样判断是否是闰年直接查看键值对结果即可，但是相应的，我们需要这个键值对的额外存储空间。

算法的空间复杂度（space complexity）公式：

```
S(n) = O(f(n))      # n为问题规模，f(n)为n锁占存储空间的函数，同样使用大O表示法表示空间复杂度
```

贴士：如果算法执行时所需的辅助空间相遇于输入的数据量来说是个常数，那么称此算法为原地工作，空间复杂度为 O(1)。

空间复杂度有以下几种情形：

- 常量空间 O(1)：存储空间固定，与输入的规模无关
- 线性空间 O(n)：存储空间是一个线性集合如数组，集合大小与输入规模 n 成正比
- 二维空间 O(n<sup>2</sup>)：分配的空间是一个二维数组集合，集合的长度、宽度与输入规模 n 成正比
- 递归空间：计算机在运行递归代码时，会专门分配一块内存，存储方法调用栈，递归越深，入栈元素越多，到达结束条件时，方法出栈。执行递归操作所需要的内存空间和递归的深度成正比，纯粹递归操作的空间复杂度也是线性的，如果递归深度是 n，那么其空间复杂度就是 O(n)

**通常我们说算法的复杂度是指时间复杂度**，因为在当前时代，对速度的追求往往大于对空间的追求。
