## 一 二叉树定义

> 二叉树： 树的每个节点最后有两个子树，即不存在度大于2的节点，则该树是二叉树。

二叉树的左子树和右子树是有顺序的，不能任意颠倒，即使树种某个节点只有一棵子树，也要区分它是左子树还是右子树。  

二叉树有五种形态：
- 空二叉树
- 只有一个根节点
- 根节点只有左子树
- 根节点只有右子树
- 根节点既有左子树又有右子树

一些特殊的二叉树：
- 斜树：有左斜树，右斜树。比如左斜树只有左侧节点，其实是一种线性结构了，节点的个数就是二叉树的深度
- 满二叉树：左右都是完好的二个孩子节点，依次递推，即所有节点的度要么为0，要么为2，且所有叶子节点都在最后一层。
- 完全二叉树（Complete Binary Tree）：叶子节点只会出现在最后2层，且最后1层的叶子节点都靠左对其

完全二叉树如图：  
![](../images/structure/binarytree-02.png)

注意：完全二叉树并不一定是满的。  

## 二 二叉树的特性  

**每层节点数**：二叉树的第i（i>=1）层上至多有2<sup>i-1</sup>个节点。  

**全部节点数**：深度为k（k>=1）的二叉树至多有2<sup>k</sup>-1个节点。  

**叶节点数与度关系**：叶节点数 = 度为2节点数 + 1
```
推导过程：

    n0 是终端节点数，n1 是度为1的节点数，n 2是度为2的节点数
    总节点数：n = n0 + n1 + n2  
    
    下图ABCD为度2节点，FGHIJ为度0叶节点，E为度1节点，总数为10

    换个角度：根节点的连接线只有分支出去，没有分支进入，
    所以分：支总线 = 节点总数 - 1，
    即：分支总数 = n-1 = n1 + 2n2，
    即：n = n0 + n1 +n2 = n1 + 2n2 + 1
```
![](../images/structure/binarytree-03.png)

**深度特性**：具有n个节点的完全二叉树深度为|log<sub>2</sub>n+1|
```
推导过程：
    深度为k的满二叉树，节点数n一定是2的k次方-1，其深度为log2(n+1)
    完全二叉树的叶节点只会出现在最下面的两层，如下图所示
```
![](../images/structure/binarytree-04.png)

**双亲与孩子特性**：一个有n个节点的完全二叉树，节点按照层序编号（1层到n层，每层从左到右），任一节点i(1<=i<=n)
- 如果i=1，则节点i是二叉树的根，无双亲
- 如果i>1，其双亲是节点
- 如果2i>n，则节点i无左孩子，节点i为叶节点，否则其左孩子是节点2i
- 如果2i+1>n，则节点i无右孩子，否则其右孩子是节点2i+1

完全二叉树（Complete Binary Tree）的特点：
- 度为1的节点只有左子树
- 度为1的节点要么是1个，要么是0个
- 倒第二层，如果有叶节点，一定在右边连续位置
- 如果节点度为1，则该节点只有孩子节点，不存在只有右子树的情况
- 同样节点数的二叉树，完全二叉树深度最小。因为同样个数的数据用完全二叉树表示，其倒数第二层至根节点都必定是排满的

假设完全二叉树的高度是h(h>=1)，那么其节点数：
- 2<sup>h-1</sup> <= n <= 2<sup>h</sup>  
- 公式： h = floor(log<sub>2</sub>n)+1    (floor是向下取整)

公式推导过程：
```
高度h需要是整数
h -1 <= 4.2 < h     则 h必定是5
即 log2n 的值需要向下取整即可（省去小数部分）
```

一颗有n(n>0)个节点的完全二叉树，从上到下，从左到右，给节点从1编号，则第i个节点有：
- i=1，是根节点
- i>2，其父节点编号是 floor(i/2)
- 2i<=n，其左子节点编号为2i
- 2i>n，则其无左子节点
- 2i+1<=n，则其右子节点编号为2i+1
- 2i+1>n,则其无右子节点


## 三 二叉树存储结构

树使用顺序存储是非常困难的，但是二叉树结构特殊，使用顺序存储也能实现。即：用一维数组存储二叉树中的节点和节点关系。  

![](../images/structure/binarytree-05.png)

图中4，6，8，9节点不存在。顺序存储虽然能够表述二叉树，但是实用性不强，比如一种极端的情况，树的深度为k，但是是右倾斜树，只有k个节点，却需要分配2k-1个存储单元，造成了空间的极大浪费。  

推荐使用链式存储，即二叉链表：每个节点最多有两个孩子，节点分别设计一数据域、两个指针域，即可表示一个节点。这样的链表叫做二叉链表。  

```go
type node struct {
    data        interface{}
    lchild      *node
    rchild      *node
}
```

二叉链表示意图：  
![](../images/structure/binarytree-06.png)

## 三 二叉树的遍历

### 3.1 二叉树的四种遍历方式

如图的二叉树要对其遍历： 
![](../images/structure/binarytree-07.png)

遍历一般是从根节点开始，当然我们也可以限制左右顺序遍历是从左开始，主要遍历方法有下列多种： 
- 前序遍历：从根节点开始，先前序遍历左子树，再前序遍历右子树，顺序为：ABDGH-CEIF
- 中序遍历：从根节点开始(不是访问根节点)，中序遍历根节点的左子树，然后访问根节点，中序遍历右子树：GDHBAE-ICF
- 后序遍历：从左到右先叶节点方式遍历左右子树，最后访问根节点：GHDBIEFCA
- 层序遍历：从树的第一层，即根节点开始访问，从上往下，从左到右遍历：ABCDEFGHI

### 3.2 遍历算法的实现

二叉树的定义和遍历都需要利用递归原理。  

前序遍历的递归算法：
```go
func (t *BitTree)PreOrderTraverse() error){
    if t == nil {
        return errors.New("遍历到nil") 
    }
    fmt.Println(t.data)
    t.lchild.PreOrderTraverse()
    t.rchild.PreOrderTraverse()
    return nil
}
```

中序遍历算法：
```go
func (t *BitTree)InOrderTraverse() error){
    if t == nil {
        return errors.New("遍历到nil") 
    }
    t.lchild.InOrderTraverse()
    fmt.Println(t.data)             // 先遍历再打印
    t.rchild.InOrderTraverse()
    return nil
}
```

后序遍历算法：
```go
func (t *BitTree)PostOrderTraverse() error){
    if t == nil {
        return errors.New("遍历到nil") 
    }
    t.lchild.PostOrderTraverse()
    t.rchild.PostOrderTraverse()
     fmt.Println(t.data)             // 全遍历再打印
    return nil
}
```