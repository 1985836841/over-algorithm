## 一 二叉搜索树概念

二叉搜索树（BST，Binary Search Tree），也称为二叉排序树，二叉查找树。  

二叉搜索树可以为空。如果不为空，则满足：
- 非空左子树的所有键值小于其根节点的键值
- 非空右子树的所有键值大于其根节点的键值
- 左、右子树本身也都是二叉搜索树

如图所示，红勾表示的即是二叉搜索树：  
![](../images/structure/bstree-01.png)  

## 二 二叉搜索树查找思想

如其名称定义，二叉搜索树的查找很便利。如果要对下列混乱的数据进行查找7是否在数据中：`{1,3,6,7,9,0,4,2,5,8}`。对这种无序的数据，我们可以使用循环操作挨个遍历，或者使用哈希表方式。  

如果现在要对一个有序的数据进行查找`{0,1,2,3,4,5,6,7,8,9}`，可以使用二分查找即可快速找出7是否在数据中。  

其实这和二叉搜索树的概念是一致的，利用二分查找的思想，这个数据序列转换为二叉搜索树后如图：  

![](../images/structure/bstree-02.svg)  

二叉搜索树与哈希表作为查找时的对比：
- 哈希表需要一个很大的数组，会造成一定的空间浪费
- 哈希表的数据是无序的，二叉搜索树其实是有序数据利用二分查找思想的转换

二叉搜索树在插入节点的时候，也需要一层层比较大小。由此也带来新的特性：`很容易获取最大值，最小值`  

注意：其实二叉搜索就是二分搜索法的是数据结构实现，其中序遍历可以得到从小到大的结果！！（当然中序遍历时如果从右侧往左侧遍历，则会产生从小到大的结果）

## 三 二叉搜索树的ADT

对于二叉搜索树来说，只需要保存根节点即可，因为其他节点都可以通过根节点找到。  

二叉树的节点内部必须保留左右子节点信息，笔者这里也保留了父节点信息，这样便于删除操作。笔者也额外提供了无父节点的二叉搜索树。  

## 三 二叉搜索树的缺陷

在数据进行插入时，如果相继插入的数据都是有序的，会造成树形成一个类似链表的结构，这会引起查找的极大性能缺失。这种插入连续数据后，分布不均匀的树称为非平衡树。
- 对于一棵平衡二叉树，查找操作效率是O(logn)
- 对于一棵非平衡二叉树，相当于编写了一个链表，查找效率上升为O(n)

为了避免这种现象，即保证树是平衡的，就要让树的每个节点的左边子孙节点个数尽量等于右边的子孙节点的个数。  

AVL树是早起的平衡树，可以实现树的平衡，因为其每个节点多存储了一个额外的数据，但是其却显示插入/删除效率不及红黑树，所以整体效率不及红黑树。  

## 四 二叉搜索树一些操作

### 4.1 查找节点的前驱

前驱节点其实就是中序遍历时，当前节点的前一个节点，即从左侧找，会找到小一点的数据，该数据一定是删除节点左子树的最大值，称之为前驱。

假设要当前节点为 n ，则查找时有三种情况：
- `node.left == nil && node.parent == nil`
  - 前驱为：无前驱节点
- `node.left == nil && node.parent != nil`
  - 前驱为：node.parent.parent.parent....
  - 终止条件为：node在parent的右子树中
- `n.left != nil`
  - 前驱为：node.left.right.right.right...
  - 终止条件为：right为nil

### 4.2 查找节点的后继

后继节点其实就是中序遍历时，当前节点的后一个节点，即从右侧找，会找到大一点的数据，该数据一定是删除节点右子树的最小值，称之为后继。  

假设当前节点为 n ，则查找有三种情况：
  - 终止条件为：node在parent的左子树中
- `node.right == nil && node.parent == nil`
  - 后继为：无后继节点
- `node.right == nil && node.parent != nil`
  - 后继为：node.parent.parent.parent....
  - 终止条件为：node在parent的左子树中
- `n.right != nil`
  - 后继为：node.right.right.right.right...
  - 终止条件为：left为nil

### 4.3 删除节点

删除节点对应需要先确定节点是否存在，即找到值对应的节点，然后依据找到的节点的不同，执行不同的操作：
- 度为0节点： 直接删除即可，如果删除的节点也是根节点，则还需要将根节点掷空
- 度为1节点： 使用子节点替换原节点，如果删除的节点也是根节点，则还需将根节点指针指向子节点
  - 如果删除的节点只有左子节点：`child.parent = node.parent   node.parent.left = child`
  - 如果删除的节点只有右子节点：`child.parent = node.parent   node.parent.right = child`
- 度为2节点： 使用期前驱/后继替换当前节点，然后删除刚才替换的前驱/后继 

对于度为2的节点，其左子树的节点都小于它，右子树的节点都大于它！！按照二叉搜索树这个特性，取代被删除节点位置的节点值必须仍然比左子树都大，并比右子树都小，这样的节点正好是其前驱/后继。删除度为2节点的问题到这里就演变为了：找到要删除节点的前驱来替换掉当前位置，或者找到后继来替换掉当前位置，最后删除前驱或者后继。其前驱、后继节点的度必定为0或者1，此时再删除前驱、后继就变得简单了！

如图所示的二叉搜索树：  

![](../images/structure/bstree-03.svg)  

如果不是叶节点，那么会有相当多的麻烦，尤其是被删除节点拥有多个子节点：
- 删除节点9：将8替换到9，或者将10替换到9即可
- 删除节点7：有两种方式
  - 左侧查找，用5替换位置7，此时3依然指向5，5的right需要指向9
  - 右侧查找，用8替换位置7，此时8的left是5，right是9
- 删除节点15：也有从左侧、右侧查找两种方式
  - 右侧查找：用18替换位置15，20的left指向19