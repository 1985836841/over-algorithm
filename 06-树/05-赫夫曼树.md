## 一 问题思考 

学生成绩的集合示例：
```
if socore < 60 {
    level = "不及格"
}
if socore < 70 {
    level = "及格"
}
if socore < 80 {
    level = "中等"
}
if socore < 90 {
    level = "良好"
}
if socore >= 90 {
    level = "优秀"
}
```

这样对成绩的水平线判断必须从60开始，然后逐级判断，如图所示：  

![](../images/structure/binarytree-18.png)   


这是有效率问题的，而且学生的成绩大多处于中等、良好范围，不及格与优秀都是少数，如果从80分开始判断就会优化很多： 

![](../images/structure/binarytree-19.png)   


我们先把这两棵二叉树简化成叶子结点带权的二叉树（注： 树结点间的边相关的数叫做权Weight） ，其中A表示不及格、 B
表示及格、 C表示中等、 D表示良好、 E表示优秀。 每个叶子的分支线上的数字就是预设的各类成绩所占百分比。  

![](../images/structure/binarytree-20.png)  

从树中一个结点到另一个结点之间的分支构成两个结点之间的路径， 路径上的分支数目称做路径长度。  

二叉树a中， 根结点到结点D的路径长度就为4， 二叉树b中根结点到结点D的路径长度为2。 树的路径长度就是从树根到每一结点的路径长度之和：  
- 二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。 
- 二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16。

## 二 赫夫曼树概述 

如果考虑到带权的结点， 结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点
的带权路径长度之和。 假设有n个权值{w1,w2,...,wn}， 构造一棵有n个叶子结点的二叉树， 每个叶子结点带权wk， 每个叶子的路径长度为lk， 我
们通常记作， 则其中带权路径长度WPL最小的二叉树称做赫夫曼树，也称为最优二叉树。  

赫夫曼树的日常应用：文件的压缩。  

实例中的WPL：
```
# 这里5是A结点的权， 1是A结点的路径长度， 其他同理
二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315 
二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220                
```

这意味着：如果我们现在有10000个学生的百分制成绩需要计算五级分制成绩， 用二叉树a的判断方法， 需要做31500次比较， 而二叉树b的判断方法， 只需要22000次比较， 差不多少了三分之一量， 在性能上提高不是一点点。  

## 三 构造赫夫曼树

### 3.1 步骤一

先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即： A5， E10， B15， D30， C40。  

### 3.2 步骤二

取头两个最小权值的结点作为一个新节点N<sub>1</sub>的两个子结点， 注意相对较小的是左孩子， 这里就是A为N<sub>1</sub>的左孩子， E为N1的右孩子， 新结点的权值为两个叶子权值的和5+10=15。  

![](../images/structure/binarytree-21.png)    

### 3.3 步骤三

将N<sub>1</sub>替换A与E， 插入有序序列中， 保持从小到大排列。 即：N<sub>1</sub>15， B15， D30， C40。  

### 3.4 步骤四

重复步骤2， 将N<sub>1</sub>与B作为一个新节点N<sub>2</sub>的两个子结点。 如图所示。 N<sub>2</sub>的权值=15+15=30。  

![](../images/structure/binarytree-22.png)    

### 3.5 步骤五

将N<sub>2</sub>替换N<sub>1</sub>与B， 插入有序序列中， 保持从小到大排列。 即：N<sub>2</sub>30， D30， C40。

### 3.6 步骤六

重复步骤2， 将N<sub>2</sub>与D作为一个新节点N<sub>3</sub>的两个子结点。 如图6-12-7所示。 N<sub>3</sub>的权值=30+30=60。

![](../images/structure/binarytree-23.png)   

### 3.7 步骤七

将N<sub>3</sub>替换N<sub>2</sub>与D， 插入有序序列中， 保持从小到大排列。 即：C40， N360。

### 3.8 步骤八

重复步骤2。 将C与N<sub>3</sub>作为一个新节点T的两个子结点， 如图所示。 由于T即是根结点， 完成赫夫曼树的构造：  

![](../images/structure/binarytree-24.png)   

此时二叉树的带权路径长度:
```
WPL=40×1+30×2+15×3+10×4+5×4=205。
```
与之前的二叉树b的WPL值220相比， 还少了15。 显然此时构造出来的二叉树才是最优的赫夫曼树。  

不过由于每次判断都要两次比较（如根结点就是a<80&&a>=70， 两次比较才能得到y或n的结果） ， 所以总体性能上反而更低了，不过这也不是讨论的终点。  

## 四 赫夫曼算法描述

- 1.根据给定的n个权值{w1,w2,...,wn}构成n棵二叉树的集合F={T1,T2,...,Tn}， 其中每棵二叉树Ti中只有一个带权为wi根结点， 其左右子树均为空。
- 2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树， 且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
- 3.在F中删除这两棵树， 同时将新得到的二叉树加入F中。
- 4.重复2和3步骤， 直到F只含一棵树为止。 这棵树便是赫夫曼树。

## 五  赫夫曼编码

### 5.1 编码

赫夫曼算法诞生的背景是为了解决当年远距离通信（主要是电报） 的数据传输的最优化问题。比如我们有一段文字内容为“BADCADFEED”要网络传输给别人， 显然
用二进制的数字（0和1） 来表示是很自然的想法。 我们现在这段文字只有六个字母ABCDEF， 那么我们可以用相应的二进制数据表示：  

![](../images/structure/binarytree-25.png)   

这样真正传输的数据就是编码后的“001000011010000011101100100011”， 对方接收时可以按照3位一分来译码。 如果一篇文章很长， 这样的二进制串也将非常的可怕。 而且事实上， 不管是英文、 中文或是其他语言， 字母或汉字的出现频率是不相同的， 比如英语中的几个元音字母“ae i o u”， 中文中的“的 了 有 在”等汉字都是频率极高。  

假设六个字母的频率为A 27， B 8， C 15， D15， E 30， F 5， 合起来正好是100%。 那就意味着， 我们完全可以重新按照赫夫曼树来规划它们。  

左图为构造赫夫曼树的过程的权值显示。 右图为将权值左分支改为0， 右分支改为1后的赫夫曼树：  

![](../images/structure/binarytree-26.png)   

此时， 我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，得到：

![](../images/structure/binarytree-27.png)   

将文字内容为“BADCADFEED”再次编码， 对比可以看到结果串变小了。
- 原编码二进制串： 001000011010000011101100100011（共30个字符）
- 新编码二进制串： 1001010010101001000111100（共25个字符）

数据被压缩了， 节约了大约17%的存储或传输成本。随着字符的增加和多字符权重的不同， 这种压缩会更加显出其优势。

### 5.2 解码

编码中非0即1， 长短不等的话其实是很容易混淆的， 所以若要设计长短不等的编码， 则必须是任一字符的编码都不是另一个字符的编码的前缀， 这种编码称做前缀编码。  

上述编码后的编码就不存在容易与1001、 1000混淆的“10”和“100”编码。如果发送方和接收方必须要约定好同样的赫夫曼编码规则， 当我们接收到1001010010101001000111100时， 由约定好的赫夫曼树可知， 1001得到第一个字母是B， 接下来01意味着第二个字符是A，其余的也相应的可以得到， 从而成功解码。  

![](../images/structure/binarytree-28.png)     

一般地， 设需要编码的字符集为{d1,d2,...,dn}， 各个字符在电文中出现的次数或频率集合为{w1,w2,...,wn}， 以d1,d2,...,dn作为叶子结点， 以
w1,w2,...,wn作为相应叶子结点的权值来构造一棵赫夫曼树。 规定赫夫曼树的左分支代表0， 右分支代表1， 则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码， 这就是赫夫曼编码。  