## 一 哈希表应用场景的引入

下列数据是0-100中任意的5个数据：`17, 31, 6, 42, 15`，现在要查询15是否在该数据中？  

首先我们肯定需要一个容器（一般是数组），将上述元素存储起来形成一个数组`arr=[17,31,6,42,15]`，接着对该数组进行查找，会有很多方法：
- 遍历数组，一一对比，其时间复杂度是O(n)
- 使用二分查找，但是二分查找的前提是有序的，还要对数组进行排序

能不能让时间复杂度立刻变为O(1)?
- 在录入上述5个数据时候，直接这样录入：arr[17]=true, arr[31]=true,arr[6]=true,依次类推
- 当要查找15是否在数据结构中，直接查看 arr[15]的值是否为true即可，这便是哈希的思想   

## 二 哈希表与散列函数  

> 散列函数：无论给该函数提供什么样的数据，都能返回一个数字，即将输入映射到了数字上。 
> 哈希表：也即散列表，利用数组来存取元素，这样就具备了数组随机存取特性，但是其存取时使用的key并不是数组索引，而是通过散列函数，维护了key与数组索引的映射

散列要求：
- 必须一致：第一次输入apple得到的是4，那么后面每次输入得到的都必须是4
- 不同输入必须映射到不同的数字上

这种使用散列函数和数组创建的数据结构叫做散列表，也即哈希表（hash table）。  

散列函数如何实现？即现在需要设计一个方案，让输入的字符串数据转换为数组下标：
- 计算机本身存在字符  编码方案，即用数字代替单词的字符

## 三 哈希表的特性

- 优势：
  - 哈希表可以提供快速的插入-删除-查找操作
  - 无论多少数据，插入和删除都非常接近O(1)时间级
- 劣势：
  - 哈希表中的数据没有顺序，所以不能以一种固定的方式（如从小到大）遍历其中的元素
  - 一般哈希表的key是不允许重复的，即不能使用相同的key来保存不同的元素

## 四 散列函数的实现-哈希化

### 4.1 散列函数实现设想一 数字相加

散列函数实现设想：每个字符都有对应的ASCII编码，将这些编码相加就能得到一个数字，即数组的索引下标：
```
# 英文单词 cats 即 对应 3 + 1 + 20 + 19 = 43
```
从上得出，当用户输入的key是 “cats”时，就去哈希表中查找索引为43的数据值即可。 

但是这里的问题是单词was、give等ASCII编码值之和也都是43，这就造成了重复！我们称之为碰撞。  

减少碰撞是散列函数考虑的重点。  

### 4.2 散列函数实现设想二 幂的连乘

在4.1的基础上，利用幂的连乘，可以让cats转换成的数字具备唯一性。  

幂的连乘：$7564 = 7*10^3 + 6*10^2 + 5*10^1 + 4*10^0$  

同理，单词字符串也可以这样做：$cats = 3*27^3 + 1*27^2 + 20*27^1 + 17*27^0 = 60337$  

该方式可以尽量保证转换后数字的唯一性，但是带来了新的问题，其生成的数字十分巨大，数组的下标不可能这么庞大，且造成了空间浪费。   

### 4.3 散列函数实现设想三 取余压缩

压缩方即将幂连乘得到的巨大整数压缩到可接受的数组下标范围，如10000。  

压缩的方式是对连乘得到的数进行取余，但是这时候又会再次遇到碰撞的情况，如47和57对10取余，其结果是一样的。  

上述实现的步骤即哈希化。虽然哈希化后实现了散列，但是也有碰撞的问题！

## 五 碰撞问题解决

碰撞冲突是不可避免的，只能提出解决办法，常见解决方案有：
- 链地址法：哈希表中的数组元素不再是单纯的一个值，而是一个链表/数组，链表中存储了所有最后哈希化后同一个索引的数据，
- 开放地址法：哈希化后的索引值处已经有数据后，将会在该索引后查找空的位置进行存储。响应的查询也遵守这个规则，如果查询哈希化的索引位置数据值与要查的值不一致，则索引+1依次查询，查询到空位置还未查询到，则证明没有该数据。
  - 此时也会产生性能：插入时遇到的位置都不是空位，是一连串填充的单元，此时称为聚集。需要一直进行探测才能插入。为了解决这个问题，可以优化探测的步长：第一次探测index+$1^2$，第二次探测index+$2^2$。不过其实这时候仍然可能会产生聚集！
  - 线性探测无论是一次探测，还是二次探测都可能会产生聚集，所以可以使用再哈希的方案。使用再哈希化的值作为步长。该函数为：`stepSize = constant - (key % constant)`。stepSzie是第二次步长，constant是个小于数组容量的质数

## 六 哈希表效率分析

哈希表中执行插入和查询的效率是很高的：
- 如果没有产生冲突，那么性能极高
- 如果发生冲突，存取时间依赖于探测长度。平均探测长度取决于装填因子，装填因子越大，探测长度也越大

装填因子：表示当前哈希表中已经包含的数据项和整个哈希表长度的比值。
```
装填因子 = 总数据项/哈希表长度
```