# 13-文件操作

## 一 文件 I/O 概述

在 Linux 中，一切皆文件，大部分设备都可以像操作文件那样使用，Linux 的目录也是文件，但是很多现代操作系统不允许直接读取目录，所有用户都是使用上层：opendir、readdir 接口来读取目录。

Linux 的文件操作函数，一般只需要理解五个系统调用：

- open：用于打开文件、设备
- close：关闭文件、设备
- read：从打开的文件、设备中的刦数据
- write：向文件、设备写入数据
- ioctl：把控制信息传递给设备驱动程序

在对文件进行读写之前，首先需要打开文件，内核会为每个进程维护一个打开文件的列表，即文件表（file table）。

表中每一项都是一个打开文件的信息：

- 指向该文件索引节点的内存拷贝指针
- 关联的元数据，如文件位置指针、访问模式

文件表的索引称为文件描述符（fds：file descriptors），由非负整数表示，其范围从 0 开始，直到上限值减 1（默认上限 1024）。由于负数不是合法文件描述符，所以函数出错不能返回有效文件描述符时，通常返回-1。

每个进程都至少包含三个文件描述符（除非显示关闭这些描述符），如下所示：

- 0：表示标准输入 stdin，Linux 中也使用宏 STDIN_FILENO 表示，代表连接到终端的输入设备，常为键盘
- 1：表示标准输出 stdout，Linux 中也使用宏 STDOUT_FILENO 表示，代表终端的屏幕
- 2：表示标准错误 stderr，Linux 中也使用宏 STDERR_FILENO 表示，代表终端的屏幕

用户可以重定向这些描述符，比如管道程序中，把一个程序的输出作为另一个程序的输入！文件描述符不仅仅用来访问普通文件，在 Linux 中，一切皆文件。使用文件描述符可以访问设备、管道、缓冲区 FIFOs、套接字 socket 等。

默认情况下，子进程会维护一份父进程的文件表副本，但当子进程关闭一个文件时，不会影响父进程的文件表。子进程和父进程也可以共享文件表（类似于线程间共享）。

## 二 文件的所有权和权限

每个文件都有一个与之相关的用户 ID 和组 ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。

为了访问文件，系统把用户分为 3 类：

- 文件用户、
- 文件组（ group） ID 相匹配的文件用户
- 其他用户。

可为以上 3 类用户分别设置 3 种权限（共计 9 种权限位）：

- 只允许查看文件内容的读权限；
- 允许修改文件内容的写权限；
- 允许执行文件的执行权限。

这里的文件要么指程序，要么是交由某种解释程序（通常指 shell 的一种，但也有例外）处理的脚本。也可针对目录进行上述权限设置，但意义稍有不同。读权限允许列出目录内容（即该目录下的文件名），写权限允许对目录内容进行更改（比如，添加、修改或删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需受文件自身访问权限的约束）。

## 三 文件 I/O 模型

Unix 系统的 I/O 模型最注重通用性，即同一套系统调用（open，write 等）所执行的 I/O，可用于所有文件类型。不过就本质而言，内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过 `lseek()` 系统调用来随机访问。

C 语言中，I/O 操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据。特定 I/O 设备的细节对程序员是隐藏的。

流存在两种方式：

- 文本流：即以文本模式读取文件。例如在 Windows 系统中，文本文件约定以一个回车符和一个换行符结尾，在 Linux 下只使用一个换行符(`\n`)结尾。
- 二进制流：适用于非文本数据，其中的字节将完全根据程序编写的形式写入到文件中，不会做任何改变。

C 语言在处理这两种文件的时都会看成是字符流，按字节进行处理，不会有所区分。在程序中，文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上。比如说，在 Win 下文件的换行符是`\r\n`，在 Linux 下换行符则是`\n`：

- 文件使用文本方式打开：Win 系统中，文件中的换行符`\r\n`会被替换成`\n`读到内存中，写入文件的时`\n`被替换成`\r\n`再写入文件
- 文件使用二进制方式打开：Win 系统中不进行`\r\n`和`\n`之间的转换，由于 Linux 下的换行符就是`\n`，所以文本文件方式和二进制方式无区别

## 四 文件指针

在 C 语言中用一个指针变量指向一个文件，该指针称为文件指针，通过文件指针才可对它所指的文件进行各种操作。

文件指针在 `stdio.h`中声明如下：

```c++
typedef struct {
 short           level;      //缓冲区"满"或者"空"的程度
 unsigned        flags;      //文件状态标志
 char            fd;         //文件描述符
 unsigned char   hold;     //如无缓冲区不读取字符
 short           bsize;     //缓冲区的大小
 unsigned char   *buffer;    //数据缓冲区的位置
 unsigned        ar;         //指针，当前的指向
 unsigned        istemp;     //临时文件，指示器
 short           token;     //用于有效性的检查
}FILE;
```

FILE 是系统使用 typedef 定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。

C 语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用，它们都是一个指向 FILE 结构的指针:

- stdin： 标准输入，默认为当前终端（键盘），我们使用的 scanf、getchar 函数默认从此终端获得数据。
- stdout：标准输出，默认为当前终端（屏幕），我们使用的 printf、puts 函数默认输出信息到此终端。
- stderr：标准出错，默认为当前终端（屏幕），我们使用的 perror 函数默认输出信息到此终端。

贴士：

- 在 C 语言中，EOF 表示文件结束符(end of file)，以 EOF 作为文件结束标志的文件，必须是文本文件。ASCII 代码值的范围是 0~127，不可能出现-1，因此可以用 EOF 作为文件结束标志。
- 当把数据以二进制形式存放到文件中时，就会有-1 值的出现，因此不能采用 EOF 作为二进制文件的结束标志。为解决这一个问题，ANSI C 提供一个 `feof`函数，用来判断文件是否结束，如果读到了结尾，返回非 0 值，没有到文件结尾返回 0。
- `feof`函数既可用以判断二进制文件又可用以判断文本文件。

## 五 文件操作 API 概述

### 5.1 文件打开函数 open()

`open()`函数用于打开文件或者创建文件，并得到该文件的文件描述符，函数如下：

```txt
# 函数原型
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);    // 用户创建新文件，额外传入mode，确定权限

# 函数参数
pathname：要打开或者创建的文件名，可以是相对路径、绝对路径
flags：文件打开方式，常用方式有：O_RDONLY(只读)、O_WRONGLY(只写）、O_RDWR(读写）
mode：用于创建文件时给与权限

# 返回值
成功：返回文件描述符
失败：返回-1，错误代码会保存在全局变量errno里
```

注意：任何文件使用之前必须调用`open()`打开，且完成读写后还需要调用`close()`关闭。

在传入打开模式后，可以使用 `|` 追加标志位，即可选参数：

- O_APPEND：表示追加，如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。其实是每次写操作前，会更新文件位置指针，指向文件末尾。
- O_CREAT：若此文件不存在则创建它，使用此选项时需要提供第三个参数 mode，表示该文件的访问权限
- O_TRUNC：如果文件已存在，并且有写权限，则标志位会把其长度截断为为 0 字节
- O_CLOEXEC：在执行新进程时，文件会自动关闭，这样就可以省去调用 fcntl()来设置标志位，避免出现竞争

还有一些标志位不适用于普通文件，适用于 FIFO、管道、socket、终端，不适用于普通文件

- O_NONBLOCK：非阻塞模式打开的操作，不会导致进程在 I/O 中阻塞（sleep）
- O_ASYNC：如果文件可读、可写，会产生信号，默认是 SIGIO
- O_SYNC：同步 I/O，贴士：该标志位对读操作无效，因为读操作本身是同步的

新建文件时候还需要确定文件的所有权限：

- 确定文件的所有者，一般文件所有者的 uid 即创建该文件的进程的有效 uid。
- 确定文件的所有用户组，默认使用创建进程的有效 gid，这也是标准 Linux 的方式
  - SystemV 采用标准方式
  - BSD 新建文件的用户组是其父目录的 gid，如果比较关注文件用户组，可以通过系统调用`fchown()`手动设置

使用了`O_CREAT`标志位，则是创建文件，此时需要 mode 参数，mode 用来提供新建文件的权限。参数 mode 是常见的 UNIX 权限位集合，比如八进制数 0644）（文件所有者可以读写，其他人只读）。针对 mode 中比特位不可移植性，POSIX 引入了按位操作常数：S_IRWXU（文件所有者读、写、执行权限）、S_IRWXO（任何人都有读、写、执行权限）等等。最终写入磁盘的权限位由 mode 参数和文件创建掩码 umask 执行按位与操作得到。umask 是进程级属性，有 login shell 设置，可以通过 umask()修改。在系统调用 open()中，umask 位要和参数 mode 取反，因此 umask 022 和 mode 参数 0666 取反后，结果是 0644。

示例：下列代码对文件 file 进行写操作，如果文件不存在，假设 umask 为 022，文件创建时的权限位 0644，如果文件已存在，长度被截断为 0

```c
    int fd;
    fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, S_IWSUR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH);
    if (fd == -1) {
        ...
    }
```

为了代码可读性，这段代码可以改写为：

```c
    int fd;
    fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        ...
    }
```

### 5.2 创建文件函数 creat()

由于`O_WRONLY | O_CREAT | O_TRUNC` 组合经常使用，专门提供了`creat()`函数：

```txt
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int creat(cont char *name,  mode_t mode)
```

函数返回值与 open 一致，其实 creat 函数即是：

```txt
int open(file, O_WRONLY | O_CREAT | O_TRUNC, 0664);
```

### 5.3 文件关闭函数 close()

`close()`函数用于关闭文件：

```txt
# 函数原型
int close(int fd);

# 函数参数
fd：文件描述符

# 返回值
成功：返回文件描述符
失败：返回-1，并设置errno值
```

close()函数会取消当前进程的文件描述符 fd 与其关联文件之间的映射，调用后 fd 不再有效，内核可以随时重用。

### 5.4 文件读取函数 read()

`read()`函数用于从打开的设备或文件中读取数据。

```txt
# 函数原型
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t len);

# 函数参数
fd: 文件描述符
buf: 读上来的数据保存在缓冲区buf中
count: buf缓冲区存放的最大字节数

# 返回值
>0：读取到的字节数，在该函数中，返回小于len的正整数才是合法的
=0：文件读取完毕，仅仅表示到达文件末尾（end-of-file，EOF）：这不是错误，只是表示到达了文件结尾，无数据可读
=-1：出错，并设置errno
```

每次调用 read()，都会从文件当前偏移开始读取 len 个字节到 buf 中。fd 的文件指针会一直向前移动，移动长度由读取到的字节数决定，但是如果 fd 指向的对象不支持 seek 操作，如字符设备文件，则读操作总是从当前位置开始。

关于该函数的返回值：

- 返回值等于 len：读取到的所有 len 个字节都被存储到 buf 中，结果与预期一致
- 返回值小于 len，大于 0：该现象原因很多，如：
  - 读取数据时出错、遇到信号中断，则结果小于 len
  - 读取 len 字节之前已经到达了 EOF，EOF 不是错误，但是如果文件本身没有可读的字节（不是读到末尾无数据可读），且描述符是以阻塞模式打开，调用会阻塞（sleep），直到有数据可读
  - 此时再次执行 read 会把剩余的字节读到缓冲区或者给出错误信息
- 返回 0：表示 EOF，
- 返回-1：也有很多情况
  - 把 errno 设置为`EINTR`，表示在读取之前收到信号，调用可以重新执行
  - 把 errno 设置为`EAGAIN`，表示无数据可用，操作阻塞，请求应该重新执行。注意这种情况只在非则色模式下发生
  - 把 errno 设置为非上述值，表示严重错误，重新执行读操作不会成功

非阻塞读：read()函数会引起阻塞，如果希望调用立即返回，即是非阻塞 I/O，设置 open()中的参数为 O_NONBLOCK 即可，此时文件以非阻塞模式打开，若没有数据可读，read()返回-1，并设置 errno 为 EAGAIN。

为了防止在非阻塞 I/O 在读取多个文件时，遗漏文件，必须对返回的 errno 进行判定：

```c++
ret = read(fd, buf, BUFSIZ);
if (nr == -1) {
    if (errno == EINTR) {
        // 业务
    }
    if (errno == EAGAIN) {
        // 业务
    }
}
```

### 5.5 文件读取函数 write()

`write()`函数用于  向打开的设备或文件中写数据：

```txt
# 函数原型
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t len);

# 函数参数
fd：文件描述符
buf：缓冲区，要写入文件或设备的数据
count：buf中数据的长度

# 返回值
>0：实际写入的字节数，该数值有可能小于count
=0：未写入任何数据
=-1：发生错误，错误代码会保存在全局变量errno里
```

注意：

- write 会将缓冲区 buf 中最多 len 个字节写入到文件中，执行成功则返回写入的字节数，并更新文件位置。
- write 不存在像 read 那样的部分写，也不存在 EOF 场景。即普通文件不需要循环执行写操作（socket 文件需要循环写来保证写入了所有请求的字节）
- 使用 O_APPEND 模式打开文件，写操作不是从文件描述符当前位置开始，而是从文件末尾开始。常见使用场合有：多进程共享日志！
- 以非阻塞模式打开文件，write()会返回-1，errno 被设置为 EAGAIN，请求可以稍后发起，但是普通文件通常不会出现该情况。

## 六 文件目录操作 API 概述

### 6.1 打开目录函数 opendir()

```txt
# 函数原型
DIR *opendir(const char *name);
```

### 6.2 读取目录函数 readdir()

```txt
# 函数原型
struct dirent *readdir(DIR *dirp);

# 函数返回值
读取到的目录指针
```

### 6.3 关闭目录函数 closedir()

```txt
# 函数原型
int closedir(DIR *dirp);

# 函数返回值
成功返回0, 失败返回-1
```

### 6.4 文件目录操作步骤

- 1 DIR \*pDir = opendir(“dir”); //打开目录
- 2 while((p=readdir(pDir))!=NULL){} //循环读取文件
- 3 closedir(pDir); //关闭目录
