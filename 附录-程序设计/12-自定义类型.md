# 12-自定义类型

## 一 结构体

结构体可以用来体现一个自定义的数据类型，有三种定义方式：

```c++
    // 方式一：先声明结构体类型再定义变量名
    struct person1 {
        char name[50];
        int age;
    };
    struct person1 p1 = {"lisi", 18};

    // 方式二：在声明类型的同时定义变量
    struct person2 {
        char name[50];
        int age;
    }p2 = {"lisi", 18};

    // 方式三：直接定义结构体类型变量（无类型名）
    struct {
        char name[50];
        int age;
    }p3,p4;
```

## 二 结构体的使用

### 2.1 结构体的字段

推荐的声明与字段调用方式：

```c++
#include <stdio.h>
#include <string.h>

struct Person {
    char name[50];
    int age;
};

int main() {

    // 在栈上分配空间
    struct Person p1;
    strcpy(p1.name, "zs");
    p1.age = 18;
    // 普通变量：通过点运算符操作结构体成员
    printf("p1.name = %s, p1.age = %d\n", p1.name, p1.age);

    // 在堆上分配空间
    struct Person* p2 = (struct Person*)malloc(sizeof(struct Person));
    strcpy(p2->name, "Obama");
    p2->age = 33;
    //如果是指针变量，通过->操作结构体成员
    printf("Name:%s Age:%d\n", p2->name, p2->age);

    // 相同类型的两个结构体变量，可以相互赋值
    struct Person p3 = p1;
    printf("p3.name = %s, p3.age = %d\n", p3.name, p3.age);

    return 0;
}
```

### 2.2 结构体嵌套

```c++
#include <stdio.h>

struct person{
 char name[20];
 char sex;
};

struct stu{
 int id;
 struct person info;
};

int main(){
 struct stu s[2] = { 1, "lily", 'F', 2, "yuri", 'M' };

 int i = 0;
 for (i = 0; i < 2; i++){
  printf("id = %d\tinfo.name=%s\tinfo.sex=%c\n", s[i].id, s[i].info.name, s[i].info.sex);
 }

 return 0;
}
```

## 三 深拷贝和浅拷贝

```c++
//一个老师有N个学生
typedef struct _TEACHER{
 char* name;
}Teacher;


void test(){

 Teacher t1;
 t1.name = malloc(64);
 strcpy(t1.name , "John");

 Teacher t2;
 t2 = t1;

 //对手动开辟的内存，需要手动拷贝
 t2.name = malloc(64);
 strcpy(t2.name, t1.name);

 if (t1.name != NULL){
  free(t1.name);
  t1.name = NULL;
 }
 if (t2.name != NULL){
  free(t2.name);
  t1.name = NULL;
 }
}
```

## 四 结构体与指针

指向普通结构体变量的指针：

```c++
#include<stdio.h>

struct stu{
 char name[50];
 int age;
};

int main(){

 struct stu s1 = { "lily", 18 };

 //如果是指针变量，通过->操作结构体成员
 struct stu *p = &s1;
 printf("p->name = %s, p->age=%d\n", p->name, p->age);
 printf("(*p).name = %s, (*p).age=%d\n",  (*p).name,  (*p).age);

 return 0;
}
```

堆区结构体变量：

```c++
#include<stdio.h>
#include <string.h>
#include <stdlib.h>

//结构体类型的定义
struct stu{
 char name[50];
 int age;
};

int main(){
 struct stu *p = NULL;

 p = (struct stu *)malloc(sizeof(struct  stu));

 //如果是指针变量，通过->操作结构体成员
 strcpy(p->name, "test");
 p->age = 22;

 printf("p->name = %s, p->age=%d\n", p->name, p->age);
 printf("(*p).name = %s, (*p).age=%d\n", (*p).name,  (*p).age);

 free(p);
 p = NULL;

 return 0;
}
```

结构体嵌套一级指针：

```c++
struct Person{
 char* name;
 int age;
};

void allocate_memory(struct Person** person){
 if (person == NULL){
  return;
 }
 struct Person* temp = (struct Person*)malloc(sizeof(struct Person));
 if (temp == NULL){
  return;
 }
 //给name指针分配内存
 temp->name = (char*)malloc(sizeof(char)* 64);
 strcpy(temp->name, "John");
 temp->age = 100;

 *person = temp;
}

void print_person(struct Person* person){
 printf("Name:%s Age:%d\n",person->name,person->age);
}

void free_memory(struct Person** person){
 if (person == NULL){
  return;
 }
 struct Person* temp = *person;
 if (temp->name != NULL){
  free(temp->name);
  temp->name = NULL;
 }

 free(temp);
}

void test(){

 struct Person* p = NULL;
 allocate_memory(&p);
 print_person(p);
 free_memory(&p);
}
```

结构体嵌套二级指针：

```c++
//一个老师有N个学生
typedef struct _TEACHER{
 char name[64];
 char** students;
}Teacher;

void create_teacher(Teacher** teacher,int n,int m){

 if (teacher == NULL){
  return;
 }

 //创建老师数组
 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n);
 if (teachers == NULL){
  return;
 }

 //给每一个老师分配学生
 int num = 0;
 for (int i = 0; i < n; i ++){
  sprintf(teachers[i].name, "老师_%d", i + 1);
  teachers[i].students = (char**)malloc(sizeof(char*) * m);
  for (int j = 0; j < m;j++){
   teachers[i].students[j] = malloc(64);
   sprintf(teachers[i].students[j], "学生_%d", num + 1);
   num++;
  }
 }

 *teacher = teachers;
}

void print_teacher(Teacher* teacher,int n,int m){
 for (int i = 0; i < n; i ++){
  printf("%s:\n", teacher[i].name);
  for (int j = 0; j < m;j++){
   printf("  %s",teacher[i].students[j]);
  }
  printf("\n");
 }
}

void free_memory(Teacher** teacher,int n,int m){
 if (teacher == NULL){
  return;
 }

 Teacher* temp = *teacher;

 for (int i = 0; i < n; i ++){

  for (int j = 0; j < m;j ++){
   free(temp[i].students[j]);
   temp[i].students[j] = NULL;
  }

  free(temp[i].students);
  temp[i].students = NULL;
 }

 free(temp);

}

void test(){

 Teacher* p = NULL;
 create_teacher(&p,2,3);
 print_teacher(p, 2, 3);
 free_memory(&p,2,3);
}
```

## 五 结构体做为函数参数

结构体普通变量做函数参数：

```c++
#include<stdio.h>
#include <string.h>

//结构体类型的定义
struct stu{
 char name[50];
 int age;
};

//函数参数为结构体普通变量
void set_stu(struct stu tmp){
 strcpy(tmp.name, "mike");
 tmp.age = 18;
 printf("tmp.name = %s, tmp.age = %d\n", tmp.name, tmp.age);
}

int main(){
 struct stu s = { 0 };
 set_stu(s); //值传递
 printf("s.name = %s, s.age = %d\n", s.name, s.age);

 return 0;
}
```

结构体指针变量做函数参数：

```c++
#include<stdio.h>
#include <string.h>

//结构体类型的定义
struct stu{
 char name[50];
 int age;
};

//函数参数为结构体指针变量
void set_stu_pro(struct stu *tmp){
 strcpy(tmp->name, "mike");
 tmp->age = 18;
}

int main(){
 struct stu s = { 0 };
 set_stu_pro(&s); //地址传递
 printf("s.name = %s, s.age = %d\n", s.name, s.age);

 return 0;
}
```

结构体数组名做函数参数：

```c++
#include<stdio.h>

//结构体类型的定义
struct stu{
 char name[50];
 int age;
};

//void set_stu_pro(struct stu tmp[100], int n)
//void set_stu_pro(struct stu tmp[], int n)
void set_stu_pro(struct stu *tmp, int n){
 int i = 0;
 for (i = 0; i < n; i++){
  sprintf(tmp->name, "name%d%d%d", i, i, i);
  tmp->age = 20 + i;
  tmp++;
 }
}

int main(){
 struct stu s[3] = { 0 };
 int i = 0;
 int n = sizeof(s) / sizeof(s[0]);
 set_stu_pro(s, n); //数组名传递

 for (i = 0; i < n; i++){
  printf("%s, %d\n", s[i].name, s[i].age);
 }

 return 0;
}
```

const 修饰结构体指针形参变量：

```c++
//结构体类型的定义
struct stu{
 char name[50];
 int age;
};

void fun1(struct stu * const p){
 //p = NULL; //err
 p->age = 10; //ok
}

//void fun2(struct stu const*  p)
void fun2(const struct stu *  p){
 p = NULL; //ok
 //p->age = 10; //err
}

void fun3(const struct stu * const p){
 //p = NULL; //err
 //p->age = 10; //err
}
```

## 一 自定义类型

常见的自定义类型（即复合类型）有：

- 结构体
- 共用体（联合体）
- 枚举

使用关键字 `typedef` 可以定义一个新名字，但不能创建新类型。

## 二 共用体（联合体）

联合体 union（也称为共用体）是一个能在同一个存储空间存储不同类型数据的类型：

- 所占的内存长度等于其最长成员的长度倍数
- 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用
- 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖
- 共用体变量的地址和它的各成员的地址都是同一地址

```c++
#include <stdio.h>

//共用体也叫联合体
union Test{
 unsigned char a;
 unsigned int b;
 unsigned short c;
};

int main(){
 //定义共用体变量
 union Test tmp;

 //1、所有成员的首地址是一样的
 printf("%p, %p, %p\n", &(tmp.a), &(tmp.b), &(tmp.c));

 //2、共用体大小为最大成员类型的大小
 printf("%lu\n", sizeof(union Test));

 //3、一个成员赋值，会影响另外的成员
 //左边是高位，右边是低位
 //低位放低地址，高位放高地址
 tmp.b = 0x44332211;

 printf("%x\n", tmp.a); //11
 printf("%x\n", tmp.c); //2211

 tmp.a = 0x00;
 printf("short: %x\n", tmp.c); //2200
 printf("int: %x\n", tmp.b); //44332200

 return 0;
}
```

## 三 枚举

枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。

- 在枚举值表中应列出所有可用值，也称为枚举元素。
- 枚举值是常量，不能在程序中用赋值语句再对它赋值。
- 枚举元素本身由系统定义了一个表示序号的数值从 0 开始顺序定义为 0，1，2 …

```c++
#include <stdio.h>

enum weekday{
 sun = 2, mon, tue, wed, thu, fri, sat
} ;

enum bool{
 flase, true
};

int main(){
 enum weekday a, b, c;
 a = sun;
 b = mon;
 c = tue;
 printf("%d,%d,%d\n", a, b, c);

 enum bool flag;
 flag = true;

 if (flag == 1){
  printf("flag为真\n");
 }
 return 0;
}
```

## 四 typedef

typedef 为 C 语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。

- 与#define 不同，typedef 仅限于数据类型，而不是能是表达式或具体的值
- #define 发生在预处理，typedef 发生在编译阶段

```c++
#include <stdio.h>

typedef int INT;
typedef char BYTE;
typedef BYTE T_BYTE;
typedef unsigned char UBYTE;

typedef struct type{
 UBYTE a;
 INT b;
 T_BYTE c;
}TYPE, *PTYPE;

int main(){
 TYPE t;
 t.a = 254;
 t.b = 10;
 t.c = 'c';

 PTYPE p = &t;
 printf("%u, %d, %c\n", p->a, p->b, p->c);

 return 0;
}
```
