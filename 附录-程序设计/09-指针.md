# 09-指针

## 一 指针概述

指针是一种数据类型，其实质就是内存地址。在开发中如果要使用一些数据的内存地址，需要用一个变量来保存该地址，这个变量称为指针变量。

指针的定义：

```c++
    char *pa;  // 定义指向字符型的指针变量pa
    int *pb;   // 定义指向整数型的指针变量pb
```

`&`取地址运算用于获取某个变量的地址：

```c++
    char *pa = &str;
    int *pb = *num;
```

`*`取值运算用于访问指针变量指向的数据：

```c++
    printf("%c, %d\n", *pa, *pb);
```

示例：

```c++
    char a = 'f';
    int b = 123;

    char *pa = &a;
    int *pb = &b;

    *pa = 'g';
    *pb += 1;

    // 二者打印一致，都是运算后的新结果
    printf("运算后的 a=%c,b=%d\n", a, b);
    printf("运算后的 *pa=%c,*pb=%d\n", *pa, *pb);

    // 笔者这里都显示是8
    printf("char类型指针占据空间：%lu\n", sizeof(pa));
    printf("int类型指针占据空间：%lu\n", sizeof(pb));
```

指针使用贴士：

- 声明指针时，`*` 表示所声明的变量为指针类型
- 使用指针时，`*` 表示操作指针所指向的内存空间

## 二 指针一些常识

### 2.1 sizeof()测量指针大小

由于指针也是一个数据类型，所以指针变量会占据**固定**的空间，根据操作系统等不同而不同。所以使用 sizeof()得到的指针空间大小总是：4 或 8，该值意义是指针变量指向存储地址的大小。

- 在 32 位平台，所有的指针（地址）都是 32 位(4 字节)
- 在 64 位平台，所有的指针（地址）都是 64 位(8 字节)

```c++
    char a = 'f';
    int b = 123;

    char *pa = &a;
    int *pb = &b;

    // 两个值相等
    printf("打印他们的地址 pa=%p,pb=%p\n", pa, pb);
```

### 2.2 野指针和空指针

**空指针**：把 NULL 赋值给指针，表示此指针变量没有指向任何变量(空闲可用)。NULL 指针并未指向任何东西，因为对一个 NULL 指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个 NULL 指针。

```c++
    int *p = NULL;          // NULL是一个值为0的宏常量：#define NULL ((void *)0)
```

**野指针**：任意数值赋值给指针变量都没有意义（只要不越界即可，如 64 位 8 字节），因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

```c++
    int *a;
    *a = 100;   // 非法操作
```

野指针产生条件：

- 指针在刚创建时不会成为 NULL 指针，其缺省值是随机的，这样就会产生野指针。所以建议在创建指针变量时就要初始化。
- 指针在 free 或 delete 后未赋值 NULL，此时只是释放指针所指的内存，却没有杀死指针本身。所以建议在释放指针后设置指针为 NULL。
- 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

### 2.3 万能指针 `void *`

`void *`指针可以指向任意变量的内存空间：

```c++
    int a = 10;

    void *p = NULL;
    p = (void *)&a; // 需要转换类型

    //使用指针变量指向的内存时，转换为int *
    *( (int *)p ) = 11;
    printf("a = %d\n", a); // 11
```

### 2.4 const 修饰的指针变量

在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用 const 修饰指针数据类型：

```c
    int a = 100;
    int b = 200;

    //指向常量的指针：修饰*，指针指向内存区域不能修改，指针指向可以变
    const int * p1 = &a;    // 等价于int const *p1 = &a;
    p1 = &b;                // 错误方式：*p1 = 111;

    //指针常量：修饰p1，指针指向不能变，指针指向的内存可以修改
    int * const p2 = &a;
    *p2 = 222;              // 错误方式：p2 = &b;
```

### 2.5 左值和右值

左值和右值是相对于赋值表达式而言的，以赋值符号 = 为界，= 左边的就是左值，= 右边就是右值。变量名编译之后，会映射成内存地址。看看 a = b 的含义，其实就是 将 "b 地址内存里面的数据"，放到"a 地址内存"中。

生成左值的运算符包括下标运算符 `[]` 和间接运算符 `*`。

不能使用常量左值修改其所指的对象：

```c++
    int a = 1;
    const int b = 2, *ptr = &a;
    b=20;           //错误：b被声明为const int
    *ptr=10;        //错误：ptr被声明为const int的指针
```

## 三 指针与数组

### 3.1 数组与指针的关系

数组地址其实就是首元素地址：

```c++
    int arr[] = {1,2,3,4};

    // 二者值一致
    printf("%p\n", arr);
    printf("%p\n", &arr[0]);
```

所以如果要用一个指针指向数组，下面的两种方式是等价的：

```c++
    char *p;
    p = arr;
    p = &a[0];
```

当指针指向数组元素的时候，可以对指针变量进行加减运算，不过`指针+1`并不是简单的将地址加 1，而是会指向数组的下一个元素：

```c++
    char arr[] = "hello world!";
    char *p = arr;
    printf("*p=%c\n*(p+1)=%c\n", *p, *(p + 1));  // h,e

    // 利用此特性进行循环操作
    int length = strlen(arr);
    for (int i = 0; i < length; i++) {
        printf("%c", arr[i]);
    }
```

直接通过数组名无法修改：

```c++
    char str[] = "hello world!";
    char *p = str;

    // 计算字符串str有多少个字符
    int count = 0;
    while (*p++ != '\0') {
        count++;
    }
    printf("str 有 %d 个字符\n", count);
```

### 3.2 指针数组

如果数组的每个元素都是指针，那么该数组是指针数组。

- 指针数组：`int *p1[3] = {&a, &b, &c}`，该示例中，取值运算符优先级更高
- 数组指针：`int (*p2)[5]`，该示例中，圆括号先运算，p2 被定义为了一个指针，指向一个有 5 个元素的数组。所以是一个指向数组的指针。

指针数组在操作字符串数组时作用较大：

```c++
    char *p[3] = {"zs", "lisi", "ww"};
    for (int i = 0; i < 3; i++) {
        printf("%s\n", p[i]);
    }
```

数组指针的意义其实就是代表数组整体，而不是像之前所述，使用数组的第一个元素来表示数组：

```c++
    int arr[5] = {1, 2, 3, 4, 5};

    // int *p = arr; 这里的p只是数组的首元素，并不是数组整体
    int(*p)[5] = &arr;
    for (int i = 0; i < 5; i++) {
        printf("%d\n", *(*p + i));
    }
```

## 四 指针与函数

### 4.1 函数形参改变实参值

```c++
#include <stdio.h>

void swap1(int x, int y){
 int tmp;
 tmp = x;
 x = y;
 y = tmp;
 printf("x = %d, y = %d\n", x, y);
}

void swap2(int *x, int *y){
 int tmp;
 tmp = *x;
 *x = *y;
 *y = tmp;
}

int main(){

    // 值传递
 int a = 3;
 int b = 5;
 swap1(a, b);
 printf("a = %d, b = %d\n", a, b);

    // 地址传递
 a = 3;
 b = 5;
 swap2(&a, &b);
 printf("a2 = %d, b2 = %d\n", a, b);

 return 0;
}
```

### 4.2 数组名做函数参数

数组名做函数参数，函数的形参会退化为指针：

```c++
#include <stdio.h>

void printArrary(int *a, int n) {
 int i = 0;
 for (i = 0; i < n; i++)
 {
  printf("%d, ", a[i]);
 }
 printf("\n");
}

int main(){
 int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 int n = sizeof(a) / sizeof(a[0]);

 //数组名做函数参数
 printArrary(a, n);
 return 0;
}
```

#### 4.3 指针做为函数的返回值

```c
#include <stdio.h>

int a = 10;

int *getA(){
 return &a;
}


int main(){
 *( getA() ) = 111;
 printf("a = %d\n", a);

 return 0;
}
```

## 五 多级指针

C 语言允许有多级指针存在，二级指针就是指向一个一级指针变量地址的指针。

```c++
    int a = 10;
    int *p = &a; //一级指针
    *p = 100; //*p就是a

    int **q = &p;
    //*q就是p
    //**q就是a

    int ***t = &q;
    //*t就是q
    //**t就是p
    //***t就是a
```
