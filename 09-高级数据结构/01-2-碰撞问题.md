## 一 碰撞问题

碰撞问题即：哈希化后的索引值处已经有数据存在了，无法用于存储。

## 二 碰撞问题解决

### 2.1 碰撞问题解决方案

碰撞冲突是不可避免的，只能提出解决办法，常见解决方案有：
- 链地址法：哈希表中的数组元素不再是单纯的一个值，而是一个链表/数组，链表中存储了所有最后哈希化后同一个索引的数据，
- 开放地址法：即寻找哈希表中新空位来放置，寻找方式有三种：
  - 线性探测：当前索引+1的位置存放元素，如果index+1后仍然不是空位，则继续+1，依次类推。
    - 线性探测问题：在不断+1过程中遇到的位置都不是空位，即是一连串的填充单元！这种现象叫做聚集。聚集引发了严重的性能问题
  - 二次探测：优化线性探测的步长，减少聚集的机会，示例：：第一次探测index+$1^2$，第二次探测index+$2^2$。
    - 二次探测问题：如果连续插入的是32-112-82-2-192这样的数据，其累加时步长是相同的，也会造成步长不一样的聚集
  - 再哈希：彻底解决线性探测问题

贴士：利用线性探测时，删除元素操作切记不能将元素设置为空，因为下次探测会遇到空指针，推荐设置为类似-1这样的不可能的值。  

### 2.2 再哈希法

再哈希法是为了彻底消除聚集问题的方案：
- 二次探测的步长是固定的：1，4，9，16....
- 现在使用一种依赖关键字的探测序列，每个关键字都不一样。那么及时不同的关键字映射到了相同的数组下标，其使用的探测序列也不相同

从上看出，再哈希法其实就是把关键字使用另外一个哈希函数，获得的结果作为步长。 

贴士：
- 再哈希函数其结果不能输出为0，因为没有步长则探测变成了原地踏步。
- 再哈希函数也不能和之前的哈希函数一样，因为如果使用一样的哈希函数，其结果还是原来的位置

再哈希函数一般如下表示：
```
# stepSize 即步长。 constant是一个小于数组容量的质数
stepSize = constant - (key % constant)      
```

## 三 哈希表效率分析

### 3.1 开放地址法

哈希表中执行插入和查询的效率是很高的：
- 如果没有产生冲突，那么性能极高
- 如果发生冲突，存取时间依赖于探测长度。
  - 链地址法：发生冲突后取决于数组索引中对应链表的长度
  - 开放地址法：发生冲突后取决于探测的长度

平均探测长度取决于装填因子，装填因子越大，探测长度也越大：
```
装填因子 = 总数据项 / 哈希表长度
```

由上述公式得知，开放地址法，其装填因子最大值也只能是1，但是链地址法的个数是不确定的。 

探测序列P和装填因子L的关系：
- 查找成功：P = (1 + 1 / (1 - L)$^2$) / 2
- 查找失败：P = (1 + 1 / (1 - L)) / 2

总结：
- 装填因子是1/2时，成功的搜索需要1.5次比较，不成功的搜索需要2.5次
- 装填因子是2/3时，分别需要2.0次和5.0次比较
- 如果装填因子更大，则比较次数会非常大
- 应该使装填因子保持在2/3以下，最好在1/2以下。但是装填因子越低，给定数量的数据项会需要越多的空间
- 实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，速度上升

二次探测和再哈希法性能相当，比线性探测性能略好：
- 成功搜索：-log<sub>2</sub>(1-loadFactor)/loadFactor
- 搜索失败：1/(1-loadFactor)

总结：
- 当填充因子是0.5时，成功和不成功的查找平均需要2次比较
- 当填充因子是2/3时，分别需要2.37和3.0次比较
- 当填充因子是0.8时，分别需要2.9和5.0次
- 因此对于较高的填充因子，相比线性探测，二次探测和再哈希法是可以忍受的

### 3.2 链地址法

链地址法比开放地址法实现简单：
- 加入哈希表有length个数据项，每个数据项都有一个链表，所有链表共有n个数据项
- 则平均数据项数目为：n/length  其实该值就是填充因子

总结：
- 成功可能只需要查找链表的一半： 1+loadFactor/2
- 失败可能需要查找整个链表：1+loadFactor

相对而言，链地址法效率好于开放地址法，实际开发中，哈希表也大多使用链地址法实现（比如Java语言内置的HashMap）。因为链地址法不会因为添加了某元素后性能急剧下降。