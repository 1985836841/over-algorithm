## 一 图数据结构的引入

在下列场景中，可能都会涉及到图数据结构，以及该数据结构的一种算法：广度优先搜索（breadth-first search，BFS）：
- 国际跳棋中，计算最少走多少步可以获胜
- 纠错运算：计算READED改为READER需要修改多少处位置

如图所示：计算双子峰到达金门大桥最近的步骤    

![](../images/structure/graph-01.png)  

图示中，前往金门大桥最短路径需要三步，该问题称为最短路径问题（shorterst-path problem），解决该问题的算法称为广度优先搜索（快速找出两样东西之间的最短距离）。  

上图问题，如果用算法解决，需要两个步骤：
- 使用图来建立问题模型
- 使用广度优先搜索解决问题

## 二 图数据结构与广度优先搜索简单定义 

图由一个一个节点、边组成。一个节点可能与众多节点直接相连，这些节点称为邻居。从节点触发，按照路径找到目的节点的算法称为广度优先搜索。  

假设你经营着一家芒果农场，想要出售这些芒果，现在需要从朋友圈中查找谁是销售商，我们会在朋友圈名单中一个一个查找，如果没有销售商，就会沿着每个朋友的朋友继续往下找去。所有的朋友关系组成了图，寻找的方式就是广度优先搜索。  

在这个朋友圈中，我们查找的时候肯定也有一定的维度，现在自己的直接朋友中查找，这称为一度关系，如果一度关系中没有，去查找朋友的朋友，这称为二度关系。  

注意：在广度优先搜索算法中，只有按添加顺序（一度关系-->二度关系）查找时，才能实现目的，即如果A与B都是经销商，而A是我们的一度朋友，结果B先加入，那么算法找出的结果反而是B，所以必须确保一度关系被优先加入，可以利用队列实现该数据结构。  

## 三 图的简单实现

图结构重要的是如何描述节点之间的关系，比如第二节中，我-->张三-->李四这样一度、二度关系。  

```go
	// 声明一个键值对对象map
	var graph map[string][]string
	graph = make(map[string][]string)

	graph["me"] = []string{"ls", "zs", "ww", "cc", "xx"}

	graph["ls"] = []string{"ls1", "ls2"}
	graph["zs"] = []string{"zs1", "zs2", "zs3"}
	graph["ww"] = []string{}
	graph["cc"] = []string{"cc1", "经销商"}
	graph["xx"] = []string{"xx1"}
```

对于上述结构，对于 ls1,zs1这样的元素，虽然有ls，zs分别指向他们，但是他妈呢自己没有指向别人，称为有向图（directed graph），其关系是单向的。  

无向图（undirected graph）没有箭头，直接相连的节点互相为邻居。  

## 四 广度优先搜索简单实现

广度优先搜索原理：  

![](../images/structure/graph-01.png)   


```go
package main

import (
	"container/list"
	"fmt"
)

func main() {

	// 声明一个键值对对象map
	var graph map[string][]string
	graph = make(map[string][]string)

	graph["me"] = []string{"ls", "zs", "ww", "cc", "xx"}

	graph["ls"] = []string{"ls1", "ls2"}
	graph["zs"] = []string{"zs1", "zs2", "zs3"}
	graph["ww"] = []string{}
	graph["cc"] = []string{"cc1", "经销商"}
	graph["xx"] = []string{"xx1"}

	// 使用golang的链表模拟队列
	queue := list.New()
	for _, v := range graph["me"] {
		queue.PushBack(v)
	}
	fmt.Println("len：", queue.Len())

	// 只要队列不为空就循环下去
	for {
		if queue.Len() <= 0 {
			break
		}

		// 取出队列第一人
		first := queue.Remove(queue.Front())
		fmt.Println("first == ", first)
		if first.(string) == "经销商" {
			fmt.Println("获取到了经销商")
			break
		} else {
			fmt.Println("不是经销商")
			// 并将这个人的朋友全部加入队列
			for _, v := range graph[first.(string)] {
				queue.PushBack(v)
			}
		}

	}

}

```

输出结果：
```
len： 5
first ==  ls                # 依次查询 ls zs ww cc 一度关系
不是经销商
first ==  zs
不是经销商
first ==  ww
不是经销商
first ==  cc
不是经销商
first ==  xx
不是经销商
first ==  ls1               # 查询 ls 的二度关系
不是经销商
first ==  ls2
不是经销商
first ==  zs1               # 查询 zs 的二度关系
不是经销商
first ==  zs2
不是经销商
first ==  zs3
不是经销商
first ==  cc1               # 查询 cc 的二度关系
不是经销商
first ==  经销商             # 找到经销商，结束循环
获取到了经销商
```

## 五 运行时间  

在整个人际关系网中搜索经销商，意味着将沿着每调边前行（边是从一个人到另一个人的箭头/链接），因此运行至少是O(变数)。  

在内部搜索中还使用了队列，用来检测每个节点，将节点加入队列需要的时间是固定的，即为O(1)，因此对每个节点都这样做需要的总时间数是O(人数)，所以广度搜索运行时间（人数+变数），通常写为O(V+E)，V为顶点（vertice），E为边数。  







