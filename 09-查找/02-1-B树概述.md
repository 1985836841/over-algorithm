## 一 B 树概述

B 树（B-tree）是一种平衡的多路搜索树，多用于文件系统、数据库索引实现等。（多路：二叉树只有左右两路，多路自然是有多个子线路）。

如图所示：

![](../images/structure/b-tree-01.png)

B 树的特点：

-   一个结点可以存储超过 2 个数据元素，也可以拥有多个子结点
-   具备二叉搜索树的性质
-   平衡性：所有结点的所有子树高度一致
-   树的高度较低

B 树拥有 `阶` 的概念，m 阶 B 树（m>=2）的每个结点最多只能拥有 m 个子结点，每个结点所能存储的数据元素个数也是有限制的，现在我们设一个结点存储的元素个数为 x，那么：

-   结点元素个数 x 的范围：
    -   根结点的 x：`1 <= x <= m-1`
    -   非根结点的 x：`⌈m/2⌉-1 <= x <= m-1`
-   结点的子结点个数为 `y = x+1`，且范围为：
    -   根结点：`2 <= y <= m`
    -   非根结点： `⌈m/2⌉ <= y <= m`，
        -   比如 m=3，2<=y<=3，可称为(2,3)树，2-3 树
        -   比如 m=4，2<=y<=4，可称为(2,4)树，2-3-4 树
        -   比如 m=5，3<=y<=5，可称为(3,5)树

贴士：

-   `⌈⌉`是向上取整的符号，`⌊⌋`是向下取整的符号。
-   m=2 时，其实就是一棵二叉搜索树
-   数据库中一般使用 200~300 阶

## 二 B-树与二叉搜索树的对应关系

m=2 时，B-树其实就是一棵二叉搜索树。而 m>2 时，B-树也和二叉搜索树有一定的渊源，如图所示：

![](../images/structure/b-tree-02.png)

只要将 18 与 33 合并，23 与 30 合并...二叉搜索树的一些多代结点，获得了一些超级结点，最后就会转变为一棵 B-树。

经过 n 代合并的超级结点，最多拥有 2$n$个子结点，至少是 2$n$阶 B 树，相应的，m 阶 B 树，最多需要 log$_2$m 代合并。

## 三 B-树的实现思路

### 3.1 搜索实现

-   先从结点内部从小到大搜索元素
-   如果命中，则搜索结束
-   如果未命中，再取对应子结点搜索元素，重复上述步骤

![](../images/structure/b-tree-03.png)  
如上图所示，查询数据 70，从根结点 40 开始查找，先查找右侧子结点，在右侧子结点内从左往右：60->80，到大 80 时发现，70 比 80 小，则从此处的子结点开始查找，就能找到 70 了。

### 3.2 添加实现

B 树种，新添加的数据必定是添加到叶子结点上。但是此时会引发一个问题，如下所示的一个四阶 B 树，插入元素 98：

![](../images/structure/b-tree-04.png)

此时插入数据 98 就会引起 B 树右下角的结点元素个数超过限制，为了维持 B 树的特性，该现象称为**上溢（overflow）**，此时的解决方案：

-   假设上溢结点的最中间元素位置为 k，则将 k 位置元素向上与父结点合并
-   将叶结点的[0,k-1]和[k+1,m-1]位置的元素分裂成 2 个子结点
-   如果父结点发生上溢，则对父结点重复上述操作

### 3.3 删除实现

-   删除叶子结点内元素：直接删除即可
-   删除非叶结点内元素：找到前驱/后继元素，覆盖需要删除的元素的值
    -   非叶结点的前驱/后继元素，必定在叶结点中
    -   所以**真正的删除元素都发生在叶子结点中**

删除元素会出现下溢（underflow）的现象，如下一棵 5 阶 B 树，删除元素 22，则该叶结点的元素个数低于 2，不符合 5 阶 B 树最小元素个数的规定（大于等于 2）。

如果发生了下溢，则该叶结点的元素个数必定是`⌈m/2⌉-2`：

-   如果下溢结点临近的兄弟结点，有至少`⌈m/2⌉`个元素，可以向其借一个元素，即会发生旋转操作：
    -   将父结点的元素插入到下溢结点的 0 号位（最小位）
    -   将兄弟结点出借的元素替换到上一步父结点失去的空位
-   如果下溢结点临近的兄弟结点，只有`⌈m/2⌉-1`个元素，兄弟不能出借，
    -   可以将父结点的对应元素与当前结点、兄弟结点合并
    -   该操作可能导致父结点下溢，需要依照重复上述步骤。
    -   如果上溢到根结点，则 B 树的高度就会+1，同样的下溢会可能造成 B 树的高度-1

**=======TODO=======**
