## 一 散列应用场景的引入

在饭店点餐时，经常会有一个菜单，菜单上菜名与价格一一对应。如果这些菜名没有按照顺序列出，那么查找一个想点的菜是非常困难的，必须从上往下依次浏览。当然，如果菜单按照名称顺序已经排序好的，那么使用二分查找法查找，就会使查找变得简单。  

但是如果菜单足够大，对于服务员来说，报上一个菜名，需要立刻给出价格，仍然是相当痛苦的，除非你能够背下整个菜单....   

查找复杂度的对比：
- 传统做法：使用数组、链表之类的结构存储，如`[{"apple",10}, {"orange", 12}]`，然后使用二分查找，时间复杂度为O(log n)
- 特殊做法：每个商品，立即都能报上价格，时间复杂度是O(1)

这个特殊做法就是散列。  

## 二 散列函数  

散列函数：无论给该函数提供什么样的数据，都能返回一个数字，即将输入映射到了数字上。  

散列要求：
- 必须一致：第一次输入apple得到的是4，那么后面每次输入得到的都必须是4
- 不同输入必须映射到不同的数字上（注意本章第四节-散列冲突）

散列函数原理：  

![](../images/algorithm/06-01.png)  

图中的数组中存储了两个商品，milk和apple的架构，分别对应索引0和索引3，那么如果散列函数中输入apple，得到的结构是3，那么我们就能立即得出apple的价格了！！！  

这种使用散列函数和数组创建的数据结构叫做散列表，也即哈希表（hash table）。  

## 三 散列的应用

散列用途非常广泛：
- 手机内的电话簿：姓名映射到电话号码上
- IP与DNS映射
- 数据库数据存储引擎

散列表还能用来防止重复：在投票场景中，同一个人不同同时投票，越来越多的人来投票时，名单就会变得很长，使用散列表来存储名单，新到投票的人如果在散列中则判断为重复投票，不能进入名单。  

web开发中，网页和一些数据经常会被缓存中，这样能加快响应速度，当用户访问某个网页时，web系统先检查散列表中是否存储了该页面，如果已经存储了直接返回，如果没有，则渲染数据后全新返回。  

## 四 散列冲突与性能

散列函数并不能100%准确的将不同的数据映射到不同的数字/位置上。有可能apple，ayocado都会映射到同一个数组索引上，那么此时该索引的位置不能只是一个单纯的数值，而应该是一个链表，如图所示：  

![](../images/algorithm/06-02.png)  

一般情况下，散列的查找速度（获取给定索引的值）速度与数组一样快，而插入和删除速度与链表一样快，但是在糟糕的情况下，散列表的各种操作都很慢。  

为了让性能更高，避免糟糕的情况，散列函数应该避免同一位置下出现过多的链表数据。  









