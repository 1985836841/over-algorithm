## 一 二分查找

假设要在电话簿中查找名字以K开头的人，肯定不会从A开始往下找，而是从电话簿的中间开始查找。  

再假设有1-10这样连续的10个数字，取出一个数，让你猜这个数是多少，每次猜测后，我会告诉你你的数值是大了，还是小了，还是对了。此时如果你从1开始猜测，也许会猜测10次...而从5开始问，瞬间就能排除掉一半的数据量。  


贴士：什么是对数？对数的运算其实是幂运算的逆运算，如下所示：  
> log<sub>10</sub>100即“多少个10相乘结果为100”，那么
> log<sub>10</sub>100=2
> log<sub>2</sub>8=3

在编程算法中，使用大O表示法表示运行时间，log都是指log<sub>2</sub>。在上述查找题目中，使用二分查找时，最多需要检查log n个元素，即列表有9个元素，最多检查3个元素，因为log 8 = 3，列表有128个元素，最多检查log 16 = 4 个元素。  


结论：
- 对于包含n个元素的列表，简单查找最多需要n步，而使用二分查找，则只需要log<sub>2</sub>n个步骤。  
- 只有有序的列表，二分查找才有用。
- 最多需要的猜测次数与列表长度相同，称为线性时间（linear time），二分查找的运行时间为对数时间或者log时间

```go
func binarySearch(arr []int, num int){

	low := 0						// 索引最小值
	high := len(arr) - 1			// 索引最大值

	if num < arr[low] || num > arr[high] {
		fmt.Println("要猜测的数据不在该列表内")
		return
	}

	var mid int						// 中间索引
	var guess int					// 当前猜的数值
	var count int					// 猜测次数

	for low <= high {

		count++

		// 计算中间索引
		mid = (low + high) / 2		

		guess = arr[mid]
		if guess == num {
			fmt.Println("猜对了，数字是：", guess)
			fmt.Println("当前猜测次数：", count)
			return
		} 
		
		if guess < num{	// 猜小了
			low = mid + 1
		} 
		
		if guess > num {	// 猜大了
			high = mid - 1
		}
	}
}

func main() {

	arr := []int{1,2,3,4,5,6,7,8,9,10}

	// 给定数字7，使用二分查找法查找
	binarySearch(arr, 7)

}	
```