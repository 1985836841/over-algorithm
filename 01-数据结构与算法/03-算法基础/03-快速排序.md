## 一 D&C方法

D&C即分而治之的意思，是一种著名的递归式问题解决方法。  

举例：将一个`1680*640`大小的长方形分成大小相等的正方形，要求这些正方形要尽可能的大。  

对于一边长是另一边长一倍的长方形，其能容纳的最大方块就是边长短的长度作为正方形边长。比如`50*25`的长方形，可以分为2个`25*25`的正方形。  

这个题目可以用递归的思想解决：先找出容纳最大的方块，如下所示：  

![](/../../images/algorithm/03-08.png)  

上图中，长方形被分为了640*640的方块，剩下一个`640*400`的余下部分，那么此时再对余下部分使用同样的算法划分，是不是就能实现结果？ 即 对`1680*640` 求结果变为了对   `640*400` 求结果：  

![](/../../images/algorithm/03-09.png)

依次类推即可获得结果：  最大的正方形应该是`80*80`  

同理，我们计算一个数字数组`[2,4,6]`内元素的和，可以使用循环累加，也可以使用D&C思想进行递归，伪代码如下：
```
sum([2,4,6]) = 
2 + sum([4,6])
```

## 二 快速排序  

#### 2.1 快排原理

快速排序也是利用了D&C思想，比选择排序快很多。  

如果要对数组进行排序，数组的元素越少，排起来越简单，最简单的数组莫过于空数组或者只有1个元素的数组，此时无需排序，排序算法只需要将数组原样返回即可，这便是基线条件。  

对于拥有2个元素的数组，任意选出一个元素后，和剩下的1个元素对比，即可实现排序。   

对于拥有3个元素的数组，比如`[33,15,10]`，利用D&C将数组分解，直到满足基线条件。选出第一个元素33，该值称为基准值（pivot），找出比该基准值大的元素，小的元素，分别放置于2个数组中，即该排序演变为两个数组(也称为分区 partitioning)：
```
比33小的数组     基准值     大于33的数组
[15, 10]        33         []
```

得到的两个子素组是无序的（当然本示例中右边的数组是空数组，太理想化了），如果子数组有序，那么其实已经排序完毕了。其实只要对子数组再次进行排序就能得到有序的子数组了。

#### 2.2 快排实现
```go
func quickSort(arr []int) []int{

	length := len(arr)

	// 基线条件：空数组或者只有1个元素可以直接返回
	if length < 2 {		
		return arr
	}

	// 选出一个基准值
	pivot := arr[0]	

	// 声明2个数组
	var less []int
	var greater []int
	
	for i := 1; i < length; i++ {

		if arr[i] <= pivot {
			less = append(less, arr[i])
			
		} else {
			greater = append(greater, arr[i])
		}
	}

	lessResult := quickSort(less)
	greaterResult := quickSort(greater)

	return  append(append(lessResult, pivot), greaterResult...)

}
```