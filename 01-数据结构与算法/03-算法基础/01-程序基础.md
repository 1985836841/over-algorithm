## 一 程序基础

#### 1.1 卡拉兹（Callatz）猜想

1950年，卡拉兹提出了一个设想：对一个自然数num，如果它是偶数，把它砍掉一半，如果是奇数，把(3n+1)砍掉一半，依次反复，一定能在某个步骤得到n=1。  

思路：
- 读入题目给出的数值n，使用while循环反复判断n是否为1
- n为1，退出循环
- n不为1，做n是奇数与偶时的处理

代码：
```go
func callatz(num int) int {
	if num <= 0 {
		fmt.Println("参数不合法")
		return 0
	}
	step := 0
	for num != 1{
		if (num % 2 == 0) {
            num = num / 2;
        } else {
            num = (3 * num + 1) / 2;
        }
        step ++;
	}
	return step
}
```

### 1.2 奥巴马编程

2014年，奥巴马编写了一个程序：在屏幕上画出正方形。要求：给出字符、边长，按照边长，使用字符绘制出正方形。  

思路：由于行间举比列间距大，为了让结果像正方形，行数实际上是列数的50%（四舍五入），行数row是`col/2+1`，列数col是偶数时，行数row是`col/2`。  

代码：
```go
func obama(col int, c string) {

	if col <= 0 {
		fmt.Println("参数不合法")
	}

	row := 0
	if (col % 2 == 1) {
        row = col / 2 + 1;
    } else {
        row = col / 2;
    }

    // 绘制第一行
    for i := 0; i < col; i++ {
		fmt.Print(c)
    }
    fmt.Println("")

    // 绘制中间部分
    for i := 2; i < row; i++ {
		fmt.Print(c)
       
        for j := 0; j < col - 2; j++{
            fmt.Print(" ")
        }
        fmt.Println(c)
    }

    // 绘制最后一行
    for i := 0; i < col; i++{
		fmt.Print(c)
    }
	fmt.Println("")
}
```

#### 1.3 进制转换

十进制数y(d1d2....dn)可以书写为：  
y = d1*10<sup>n-1</sup> + d2*10<sup>n-2</sup> + ... + dn-1 * 10 + dn;  

同样，P进制数x(a1a2....an)可以书写为：  
x = a1*P<sup>n-1</sup> + a2*P<sup>n-2</sup> + ... + an-1 * P + an;  

此时，如果要P进制数x转换为十进制数：
```go
	var y = 0
	var p = 1
	for x != 0 {
		y = y + (x % 10) * p;
		x = x / 10;
		p = p * P
	}
```

如果要将十进制数y转换为Q进制数z：
```go
// 除基取余法：基即将要转换成的进制Q，每次讲待转换数除以Q，然后将得到的余数作为低位存储，而商则继续除以Q并进行上面的操作，最后当商为0时，将所有位从高到低输出就可以得到z
```

#### 1.4 字符串处理

判断是否是回文：正向读和反向读都是一样的，如“level”。  

思路：我们首先会想到直接将该字符串倒置生成新的字符串，新旧字符串对比即可出结果。新思路：只取出前半部分（不包括i==len/2），只要前半部分和后半部分对称位置相等即可。
```go
func judge(s string) bool{

	len := len(s)

	for i := 0; i < len; i++ {
		if s[i] != s[len - 1 - i] {
			return false
		}
	}
	return true
}
```

