## 一 选择排序

### 1.1 选择排序概念

冒泡排序的思想是不断的交换，最终完成排序，选择排序的基本思想是每次遍历找到最大的元素，将最大的元素放置在数组末尾。本轮遍历结束后，最后一个元素就是最大元素。    

选择排序即：选择最大值！！

### 1.2 选择排序实现
```go
func SelectSort(arr []int) {

	if arr == nil || len(arr) < 2 {
		fmt.Println("数组不满足要求")
		return
	}

	count := 0
	// 从0开始查找
	for i := len(arr) - 1; i > 0; i-- {

		// 从0开始查找，那么需要找出最小值
		count++
		max := i
		for j := i + 1; j <= len(arr) - 1; j++ {
			if arr[max] < arr[j] {
				max = j
			}
		}

		if max != i {
			temp := arr[i]
			arr[i] = arr[max]
			arr[max] = temp
		}

	}

	fmt.Println("运行次数：", count)
	fmt.Println("运行结果：", arr)
}
```

测试数组：`arr := []int{1, 0, 2, 3, 6, 4, 5, 7, 8, 9}`，运行次数只有9次。

### 1.3 选择排序时间复杂度

简单选择排序最大的特点就是交换移动数据次数相当少(冒泡排序每次都会交换，而选择排序是再一轮比较完后再交换)， 这样也就节约了相应的时间。无论是最好情况还是最坏情况，选择排序的时间复杂度都是一致的，此时需要比较 `sigma(i=1, n-1, n-i)=(n-1)+(n-2)+...+1=n(n-1)/2`。时间复杂度依然为O(n$^2$)。  

虽然时间复杂度与冒泡排序相同，但是选择排序在性能上仍然会略优于冒泡排序。  
