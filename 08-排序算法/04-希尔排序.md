## 一 希尔排序概述

大多数排序算法，都无法绕过复杂度O(n$^2$)，而希尔排序（ShelloSort）是首次突破该时间复杂度的算法之一。  

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。希尔排序针对插入排序的以下两点提出了改进：  
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；  

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。  

假如需要对 {81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15} 进行排序，其步骤：
- 按照间隔为5进行分组
  - 要处理的数据为：(81,35),(94,17),(11,95),(96,28),(12,58),(35,41),(17,75),(95,15)
  - 原数组处理结果：{35, 17, 11, 28, 12, 41, 75, 15, 96, 58, 81, 94, 95}
- 再让间隔为3进行分组
  - 要处理的数据为：(35,28,75,58,95),(17,12,15,81),(11,41,96,94)
  - 原数组处理结果：{28, 12, 11, 35, 15, 41, 58, 17, 94, 75, 81, 96, 95}
- 再让间隔为1进行分组
  - 要处理的数据为：(28, 12, 11, 35, 15, 41, 58, 17, 94, 75, 81, 96, 95)
  - 原数组处理结果：{11, 12, 15, 17, 18, 35, 41, 58, 75, 81, 94, 95, 96}

希尔认为初始间距是N/2，可以简单的把每趟排序分成凉拌，也就是说如果N=100，则增量依次为：50，25，12，6，3，1。这个方法的好处是不需要在开始排序前为找合适的增量而进行任何的计算。  

## 二 希尔排序代码

示例使用希尔排序原稿中的增量：
```go

func ShellSort(arr []int){

	length := len(arr)
	gap := int(math.Floor(float64(length / 2)))

	for gap >= 1{
		// 以gap作为间隔进行分组，对分组插入排序
		for i := gap; i < length; i++ {

			temp := arr[i]
			j := i

			for j > gap - 1 && arr[j - gap] > temp{
				arr[j] = arr[j - gap]
				j -= gap
			}

			arr[j] = temp
		}
		gap = int(math.Floor(float64(gap / 2)))
	}
}
```

## 三 希尔排序时间复杂度

希尔排序的效率和增量有关，其最坏时间复杂度为O(n$^2$)，但是通常情况下其效率都要比该值好！  

当然也有一些其他增量设计思路（注意其时间复杂度均未被证明）：
- Hibbard增量序列：算法为2$^k$-1，也就是1，3，5，7...等
  - 其最坏时间复杂度为O(n<sup>3/2<sup>)
  - 其平均复杂度为O(n<sub>5/4</sub>)
- Sedgewick增量序列：直接使用该序列{1,5,19,41,109,...}，该序列中的项或者是9*4$^i$ - 9*2$^i$ + 1 ，或者是 4$^i$ - 3*2$^i$ + 1
  - 其最坏时间复杂度为O(n<sup>4/3<sup>)
  - 其平均复杂度为O(n<sup>7/6<sup>)，尚未被证明