## 一 链表

### 1.1 链表概述

顺序表的底层由数组实现，顺序表逻辑关系上的相邻元素在物理位置上也相邻，这让顺序白可以随机存取表中任一元素，但是在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后移动。

上述问题出现的原因是：所有的元素存储位置都是相邻的，中间没有缝隙，也就不能快速插入，同样，删除后留下的空隙也需要弥补上。

链表：

> 用一组任意的存储单元存储线性表中的数据元素，其存储单元可以是连续的，也可以是不连续的

如图所示：  
![](../images/structure/01-06.svg)

总结：对于插入或者删除数据越频繁的操作，链表的效率优势越明显。

### 1.2 链表的节点

链表的定义意味着链表的数据元素可以利用内存中未被占用的任意位置，那么我们需要知道数据元素的前驱、后继时就无法像顺序表那样直接利用索引来查询了，所以在链表的数据结构中，除了要存储数据元素信息外，至少还要存储它的后继元素的存储地址。

结点 node：

> 链表中的每个数据元素 a<sub>i</sub>，既要存储本身信息，也要存储后继信息，这两部分组成的数据元素 a<sub>i</sub>称为结点（node）

一个节点包含两个域：

- 数据域：存储数据元素信息
- 指针域：存储直接后继的位置，指针域中存储的信息称为指针或者链

n 个节点链结成了一个链表，即是线性表的链式存储结构。

## 二 头指针与头结点

在顺序表中，我们申请了一个数组，并使用引用变量表示该数组，链表中这些无数的数据无法也需要一个引用数据来标识。头指针即是指向链表第一个元素的指针，沿着头指针可以直接查找到链表中的所有元素位置，所以可以在数据结构中使用头指针来表示链表。

如下图所示：

![](../images/structure/list-04.svg)

为了方便对链表进行操作，有时候会在单链表的第一个节点前附设一个结点，称为头节点。头节点的数据域一般不存储任何信息，或者存储如线性表的长度等附加信息。头节点的指针域存储指向第一个节点的指针。

如图所示：

![](../images/structure/list-05.svg)

头指针：

- 头指针指向第一个节点的指针，若链表有头节点，则指向头节点
- 头指针具备标识作用，常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不为空，是必要元素

头节点：

- 为了操作的统一设立，放在第一个节点之前，一般没有实际意义
- 有了头结点，第一节点前插入、删除第一节点等操作会更加简便
- 头节点不是链表必备元素

贴士：

- 头节点虽然可以保存长度数据，也为插入、循环等操作带来了便利，但是同时也破坏了链表真实的结构含义。
- 有些场景下，也会有尾节点，链表最后一个元素指向尾节点 ，尾结点的 next 为空，这样的行为均是为了一些操作的简便

## 三 单链表

单链表：

> 链表的指针域中只包含一个指针域，即称为线性链表或者单链表

单链表的最后一个元素没有直接后继，即其指针为空。

但是如果我们不知道第 i 个结点的位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构相比没有太大优势。一旦知道精确的位置，无论插入多少个元素，找到第 i 位置的指针复杂度为 O(n)，但是插入只是简单的移动指针，时间复杂度都是 O(1)，而顺序表，每次移动都是 O(n)。

## 四 单链表抽象数据类型

定义链单链表每个节点名为 Node，其链表名为 LinkList。这里采用带头结点的做法，如图所示：

![](../images/structure/list-06.svg)

取巧的地方是：LinkList 本身其实可以看做一个 Node，即头结点，内部的指针域是链表的首元节点，数据域是链表的长度。也就是说上图的第一个方框其实也是一个 Node 类型！这样能够有效节省内存空间，避免不必要的浪费。

## 五 单链表 C 实现

## 附 单链表其他语言实现

### Go 实现

```go
/*
 *  单链表：带头节点
 */
package list

import (
 "fmt"
)

// 结点结构体
type LinkedNode struct {
 data interface{}
 next *LinkedNode
}

// 单链表结构体
type LinkedList struct {
 head *LinkedNode  // 头节点，头节点之后的第一个节点可以称呼为首元节点
}

// 构造表
func NewLinkedList() *LinkedList {
 head := &LinkedNode{
  data: 0,    // 这里使用头节点存储链表的长度，不包含头节点
  next: nil,
 }
 return &LinkedList{
  head:  head,
 }
}

func (l *LinkedList)PushBack(e interface{}) {
 // 构造要插入的节点
 insertNode := &LinkedNode{
  data: e,
  next: nil,
 }
 // 当前循环到的节点
 currentNode := l.head
 for currentNode.next != nil {
  currentNode = currentNode.next
 }
 currentNode.next = insertNode
 l.head.data = l.head.data.(int) + 1
}

func (l *LinkedList)PushFront(e interface{}) {
 // 构造要插入的节点
 insertNode := &LinkedNode{
  data: e,
  next: nil,
 }
 insertNode.next = l.head.next
 l.head.next = insertNode
 l.head.data = l.head.data.(int) + 1
}

// 插入元素
func (l *LinkedList)Insert(index int, e interface{}) bool {

 if index < 1 || index > l.Length() + 1 {
  fmt.Println("插入位序不正确")
  return false
 }

 if index == 1 {
  l.PushFront(e)
  return true
 }

 if index == l.Length() + 1 {
  l.PushBack(e)
  return true
 }

 // 构造要插入的节点
 insertNode := &LinkedNode{
  data: e,
  next: nil,
 }

 // 找到要插入位置的前一个节点
 prevNode := l.head
 for i := 1; i <= index - 1; i++ {
  prevNode = prevNode.next
 }

 // 执行插入
 insertNode.next = prevNode.next
 prevNode.next = insertNode
 return true
}

// 删除元素
func (l *LinkedList)Delete(e interface{}) bool {

 // 找到该元素
 delNode := l.curNode(e)
 if delNode == nil {
  fmt.Println("未找到该元素")
  return false
 }

 // 获取前驱：这时候就是单链表的不足了，必须再次循环，或者在查找节点的时候制作多返回值
 prevNode := l.prevNode(e)
 if prevNode == nil {
  fmt.Println("未找到前驱元素")
  return false
 }

 prevNode.next = delNode.next
 l.head.data = l.head.data.(int) - 1
 return true

}

// 根据元素获取节点
func (l *LinkedList)curNode(e interface{}) *LinkedNode {

 if l.Length() <= 0 {
  fmt.Println("链表为空")
  return nil
 }

 currentNode := l.head
 for currentNode.next != nil {
  currentNode = currentNode.next
  if currentNode.data == e {
   return currentNode
  }
 }

 fmt.Println("未找到该元素")
 return nil
}

// 获取前驱节点：注意是节点，不是值，有了节点，再写取值方法、任意位置插入方法也很方便
func (l *LinkedList)prevNode(e interface{}) *LinkedNode {

 if l.Length() <= 0 {
  fmt.Println("链表为空")
  return nil
 }

 // 注意：如果没有头节点，还需要额外判断是否是首元素，因为首元素无前驱
 currentNode := l.head
 var prevNode *LinkedNode
 for currentNode.next != nil {
  prevNode = currentNode
  currentNode = currentNode.next
  if currentNode.data == e {
   return prevNode
  }
 }

 fmt.Println("未查找到当前节点")
 return nil
}

// 获取后继节点：注意是节点，不是值，有了节点，再写取值方法、任意位置插入方法也很方便
func (l *LinkedList)nextNode(e interface{}) interface{}{

 if l.Length() <= 0 {
  fmt.Println("链表为空")
  return nil
 }

 currentNode := l.head
 for currentNode.next != nil {
  currentNode = currentNode.next
  if currentNode.data == e {
   if currentNode.next == nil {
    fmt.Println("末尾元素无后继节点")
    return nil
   } else {
    return currentNode.next
   }
  }
 }
 fmt.Println("未查找到当前节点")
 return nil
}



// 获取长度
func (l *LinkedList)Length() int {
 return l.head.data.(int)
}

// 清空
func (l *LinkedList) Clear() {
 l.head.data = 0
 l.head.next = nil
}
```
