## 二 双向链表

单链表和循环链表的结点都仅仅只有一个指示后继的指针域。查找后继的时间复杂度为 O(1)，而查找前驱的时间复杂度为 O(n)，

## 三 双向循环链表

在单链表中，有了 next 指针，使得查找下一个结点的时间复杂度为 O(1)，但是如果要查找上一个结点的话，最坏的时间复杂度就是 O(n)，因为每次都要从头开始遍历查找。

在单链表的每个结点中，额外设置一个纸箱前驱结点的指针，这样就能实现复杂度为 O(1)的查询前驱结点。

实际开发中，双向循环链表由于各项性能较高，使用较为广泛。

由于循环链表比起单链表的改变，大多情况下都是`while()`中判断结点 next 是否为空，改变为结点 next 是否为头结点即可，所以笔者这里就不再书写简单的循环链表等数据结构。

```go
/*
*  双向循环链表：带头结点的双向链表
*/
package list

import (
 "fmt"
)

// 结点结构体
type DCircleNode struct {
 data  interface{}
 next  *DCircleNode
 prev  *DCircleNode
}

// 单链结构体
type DCircleList struct {
 head   *DCircleNode // 该双向循环链表的头结点
 length int    // 笔者这里不再像单向链表那样把元素个数存储在头结点中
}

// 构造表
func NewDCircleList() *DCircleList {
 head := &DCircleNode{
  data: 0,
  next: nil,
  prev: nil,
 }
 head.next = head
 head.prev = head

 return &DCircleList{
  head:   head,
  length: 0,
 }
}

func (l *DCircleList)PushBack(e interface{}) {
 // 构造要插入的结点
 insertNode := &DCircleNode{
  data: e,
  next: l.head,
  prev: nil,
 }
 // 当前循环到的结点
 currentNode := l.head
 for currentNode.next != l.head {   // 循环链表的末尾结束标志是 不等于 l.head
  currentNode = currentNode.next
 }
 currentNode.next = insertNode
 insertNode.prev = currentNode
 l.length++
}

func (l *DCircleList)PushFront(e interface{}) {

 // 构造要插入的结点
 insertNode := &DCircleNode{
  data: e,
  next: nil,
  prev: l.head,
 }

 if l.Length() == 0 {
  insertNode.next = l.head
  l.head.prev = insertNode
  l.head.next = insertNode
  l.length++
  return
 }

 // 插入位置的后继结点更改
 nextNode := l.head.next
 nextNode.prev = insertNode
 insertNode.next = nextNode

 // head结点更改
 l.head.next = insertNode
 l.length++
 return
}

// 插入元素
func (l *DCircleList)Insert(index int, e interface{}) bool {

 if index < 1 || index > l.length + 1 {
  fmt.Println("插入位序不正确")
  return false
 }

 if index == 1 {
  l.PushFront(e)
  return true
 }

 if index == l.Length() + 1 {
  l.PushBack(e)
  return true
 }

 // 常规插入:先获取插入位子
 currentNode := l.head
 for i := 1; i <= index; i++ {
  currentNode = currentNode.next
 }
 prevNode := currentNode.prev

 // 执行插入
 insertNode := &DCircleNode{
  data: e,
  next: currentNode,
  prev: prevNode,
 }
 currentNode.prev = insertNode
 prevNode.next = insertNode
 l.length++
 return true
}

// 获取长度
func (l *DCircleList)Length() int {
 return l.length
}

// 清空
func (l *DCircleList)Clear() {
 l.head.next = l.head
 l.head.prev = l.head
 l.length = 0
}
```
