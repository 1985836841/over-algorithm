# 07-线性表应用

## 一 常见题目

### 1.1 约瑟夫环

约瑟夫环是最经典的线性表题目，使用的数据结构是循环链表。

约瑟夫环描述：$n$ 个人围成一圈进行报数。选取一个正整数值 $m$ 作为报数值（$n<m$），从第一个人开始按照顺时针从 1 开始报数，报到 m 时停止，报道 m 的人出列。从出列的下一个人开始重新报数，如此循环，直到环中最后剩下的人为优胜者。

那么问题来了：如果现在 n = 8， m = 3，如何安排自己的位置才能让自己成为优胜者？

实现步骤：

```txt
1） 构建一个 n 个结点的链表
2） 执行 n-1 次报数，每次循环从1开始，连续加 1 计数到 m-1 次，同时让检测指针向后移动 m-1 个结点。
    移动到第 m 个结点时删除该节点，并打印该结点编号
3） 从被删除节点的下一个节点开始再次遍历，依次类推，直到只剩下最后无法完整循环的节点时跳出循环。
```

算法时间复杂度：$(O(m*n))$

源码：z-questing-03-01

```c++
#include <stdio.h>
#include <stdlib.h>
#include "../list/CircleList.c"

// L 循环链表， cur 当前检测指针，m 最大出列序号， n 参与约瑟夫环的人数
void Josephus(CircleList *L, int m, int n){
    // 获取当前检测指针：一般这里直接认为都是从第一个有值节点开始
    Node *p = L->head->next;
    if(p == NULL){
        printf("链表数据有误\n");
        exit(1);
    }
    printf("从 %d 开始报数\n", p->data);

    Node *temp; // 循环到要删除结点的前一个结点
    for(int i = 0; i < n; i++){
        for(int j = 1; j < m; j++){
            temp = p;
            p = p->next;
            // 若为头结点，则跳过
            if(p == L->head){
                p = p->next;
            }
        }
        printf("%d\n", p->data);

        // 删除该结点
        temp->next = p->next;
        free(p);

        // 下一次报数从下一个结点开始
        p = temp->next;
        if(p == L->head){
            temp = p;
            p = p->next;
        }

    }
}

int main(){
    // 构建一个链表： n = 8， m = 3，依次出列顺序为：3 6 1 5 2 8 4
    CircleList *L = newCircleList();
    // ==TODO==可以使用尾插法、头插法等创建，这里暂时未制作
    insert(L, 1, 1);
    insert(L, 2, 2);
    insert(L, 3, 3);
    insert(L, 4, 4);
    insert(L, 5, 5);
    insert(L, 6, 6);
    insert(L, 7, 7);
    insert(L, 8, 8);
    display(L);

    Josephus(L, 3, 8);
    return 0;
}
```

### 1.2 获取链表中间元素

### 1.3 判断链表是否有环

### 1.4 求倒数第 N 个节点

### 1.5 反转链表

## 二 实践应用

### 2.1 LRU 缓存淘汰算法

缓存是基于内存的高效存取技术，我们最常见的缓存使用是利用 Map 对象来存储键值对数据。

缓存的大小有限，当缓存被用满时，使用率较低的缓存数据就应该被清理下来，热点数据应该保留。决定缓存去留的算法一般称为缓存淘汰策略，常见的策略有：

-   FIFO（First In，FirstOut）
-   最少使用策略 LFU（Least Frequently Used）
-   最近最少使用策略 LRU（LeastRecently Used）

使用链表来存储缓存数据时，约定：

-   访问一个缓存数据时，从表头开始顺序遍历
-   靠近链表尾部的结点是较早时间之前访问的

实现 LRU：根据实际业务情况，限制链表的长度，也即缓存大小。当数据没有在缓存中时，则插入链表头部，若此时链表已满，则删除尾结点。如果再引入哈希表来记录数据的存储位置，那么查询缓存的效率就会接近 O(1)。
