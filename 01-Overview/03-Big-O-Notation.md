## 一 大O阶推导

### 1.0 推导大O阶方法

大O表示法用来表示算法的运行效率，假设列表包含n个元素，简单查找每个元素，需要执行n次操作，运行时间是O(n)。  

大O并不表示具体的运行时间，而是让你能够比较操作数，用以指出算法运行时间的增速。大O表示法指出了算法最糟糕情况下的运行时间。  

分析算法的复杂度，最关键的是分析循环结构的运行情况。记住一点：**将算法中基本操作的执行次数作为算法时间复杂度的度量**，即时间复杂度不是算法程序的运行时间，而是其中基本操作的总次数！  

常用的推导大O阶的方法：
- 用 常数1 取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项目存在且不是1，则去除与这个项相乘的常数
- 得到结果就是大O阶  

示例：`T(n) = 3n + 1`，那么其大O表示的时间复杂度为：`T(n) = O(n)`

### 1.1 线性阶 O(n)

计算 1,2,3....100 之间内所有数的和：
```go
func Sum(n int) int{            // n 在本次函数为100
    sum := 0
    for i:= 0; i < n; i++ {
        sum += i                // n步
    }
    return sum
}
```

在上述算法中，执行的算法步骤是 `f(n) = n`， 算法的复杂度为O(n)。  

### 1.2 常数阶 O(1)

上述求和题目只是常规解法，数学家高斯在小时候在几分钟内给出了答案，他的思路如下：
```
1   +  2   +  3   +  ...  +  100
100 +  99  +  98  +  ...  +  1

结果：( 1 + 100) * 100 / 2
```
上述算法使用代码形式：
```go
func Sum(n int) int{            // n 在本次函数为100
    sum := 0
    sum = ( 1 + n ) * n / 2;   // 这里执行了三步
    return sum
}    
```
在上述算法中，执行的算法步骤是三步：`f(n) = 3` ，根据推导规则1，常数3改为1，且没有最高项，算法的时间复杂度为O(1) 。  

执行时间恒定的算法（不会随着n的变化而变化），我们成为常数阶。  

### 1.3 平方阶

循环的时间复杂度为O(n)，那么循环嵌套的复杂度如下所示为：O(m * n)：
```go
func fn(){
    m := 100
    n := 100
    for i = 0; i < m; i++ {
        for j = 0; j < n; j++ {
            // 时间复杂度为O(1)的程序序列
        }
     }
}
```

总结：
> 循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。  

再看一个例子：
```go
func fn(){
    n := 100
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            // 时间复杂度为O(1)的程序序列
        }
     }
}
}
```
上述算法总执行次数为： `n + (n-1) + (n-2) + ... + 1 `，即 `n*(n+1)/2`，拆开后得到：n<sup>2</sup>/2 + n/2 ，最终的时间复杂度为：O(n<sup>2</sup>)

### 1.4 对数阶

首先理解中学数学中的对数。对数的运算其实是幂运算的逆运算，如下所示：  
- log<sub>10</sub>100 = 2       即 多少个10相乘结果为100
- log<sub>2</sub>8 = 3          即 多少个2相乘等于8

示例：`T(n) = logn + 1`，执行次数是对数计算的
```go
func fn(n int){
    for i := n; i > 1; i /= 2 {
        fmt.Println(i)              // 执行logn次
    }
    fmt.Println("运行结束")         // 执行1次
}
```

由于每次count乘以2以后，距离n更近了一分，即有多少2相乘后大于n，则会退出循环，2<sup>x</sup>=n得到x = log<sub>2</sub>n。其时间复杂度为：O(log<sub>2</sub>n)，在编程中简写为：O(log n)。  

### 1.5 旅行商问题

O(n!)的时间极长，主要用来解决计算机领域中的旅行商问题，其计算时间增加的异常快，且改进可能性较低。  

示例：现在有一位旅行商，需要前往5个城市，而且要确保行程最短，那么就需要将5个城市的所有排序方式的长度和都计算一次，要执行120次操作，城市数目增加到6个时是720次，到了7个就要执行5040次！  

那么到了n个城市，就要执行n!(n的阶乘)次操作才能计算出结果，所以运行时间为O(n!)，也称为阶乘时间。  

## 二 总结常见的时间复杂度

**常见的时间复杂度**（从快到慢）：  

| 执行次数                           | 阶               | 非正式称呼 | 对应算法   |
| ---------------------------------- | ---------------- | ---------- | ---------- |
| 12                                 | O(1)             | 常数阶     | 普通运算   |
| 5log<sub>2</sub>n+20               | O(logn)          | 对数阶     | 二分查找法 |
| 2n+3                               | O(n)             | 线性阶     | 简单查找   |
| 5log<sub>2</sub>n+2n               | O(nlogn)         | O(nlogn)阶 |            |
| 3n<sup>2</sup>+2n+1                | O(n<sup>2</sup>) | 平方阶     | 选择排序   |
| 5n<sup>3</sup>+3n<sup>2</sup>+2n+1 | O(n<sup>3</sup>) | 立方阶     |            |
| 2<sup>n</sup>                      | O(2<sup>n</sup>) | 指数阶     |            |
| n阶乘                              | O(n!)            | 阶乘       | 旅行商问题 |
| n<sup>n</sup>                      | O(n<sup>n</sup>) |            |            |

**常用的时间复杂度顺序**：  
O(1)<=O(logn)<=O(n)<=O(nlogn)<=O(n<sup>2</sup>)<=O(n<sup>3</sup>)<=O(2<sup>n</sup>)<=O(n!)<O(n<sup>n</sup>)