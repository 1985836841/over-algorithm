## 一 一元多项式表示方式

一元多项式的数学表达方式：  
$P_n(x)=p_0+p_1x+p_2x^2+...+p_nx^n$     

一元多项式的计算机表达方式（使用线性表P表示，指数i隐藏在系数$p_i$的序号内）：
$P=(P_0,P_1,P_2,...,P_n)$     

两个多项式相加，设$m<n$：$R_n(x)=P_n(x)+Q_m(x)$ 的线性表表示方法是：   
$R=(p_0+q_0,p_1+q_1,p_2+q_2,...,p_m+q_m,p_m+1,p_n)$   

显然，可以对P、Q、R使用顺序存储结构，可以方便解决上述问题，但是多项式的次数可能很高且变化很大，使得顺序存储结构的最大长度很难确定，尤其是在处理类似下列式子，指数变大后，会造成顺序存储空间的空前浪费：  
$S(x)=1+2x^9$$^9$    

如果只存储非零系数，那么还要额外存储对应的指数，一元n次方多项式可写成：  
$P_n(x)=p_1x^e$$^1$$+p_2x^e$$^2$$+,...,+$$p_mx^e$$^m$  

若用一个长度为m，且每个元素有两个数据项的线性表表示：  
$((p_1,e_1),(p_2,e_2),...,(p_m,e_m))$  

该表示方法在最坏的情况下（所有系数均不为0），会比只存储系数方案多存储一倍数据，但是对$S(x)$则会大大节省空间。  

实际开发中，采用哪种结构，需要视多项式作何种运算决定，若只对多项式进行求值等不改变多项式系数和指数的运算，采用顺序存储，否则采用链式存储。  

## 二 一元多项式相加算法

算法规则：
- 两个一元多项式中所有指数相同的项，对应系数相加，若和不为0，构成 结果多项式 中的一项
- 两个一元多项式中所有指数不相同的项，分别复制到 结果多项式 中

综上所得：结果多项式（即和多项式）中的元素应该是从相加的两个多项式链表中摘取。  

## 三 一元多项式 加减乘除运算示例

创建多项式时，无论指数项按什么顺序输入，输出均能实现以升幂顺序输出，且输入时有相同指数项时能够实现合并：
```c
// 若有序链表L中存在与e满足判断函数compare()取值为0的元素，则q指示L中第一个
// 值为e的结点的位置，并返回TRUE，否则q指示第一个与e满足判断函数compare()>0的元素前驱的位置，并返回FALSE
Status LocateElem(LinkList L, ElemType e, Position &q, int (* compare)(ElemType, ElemType));

// 按有序判定函数compare()的约定，将值为e的节点插入到有序链表L的适当位置上
Status OrderInsert(Linklist &L, ElemType e, int(* compare)(ElemType, ElemType));
```

抽象数据类型
```c
typedef struct {
    float coef; // 系数
    int expn;   // 指数
}term, ElemType;        // term用于被ADT，ElemType为LinkList数据对象名

typedef LinkList polynomial;        // 用带头结点的有序链表表示多项式

void PolybCreate(polynomail &P, int m); // 输入m项的系数和指数，建立表示一元多项式的有序链表P
void PolyDestroy(polynomail &P);
void PolyDisplay(polynomail &P);

// 加减乘除
void PolyAdd(polynomail &Pa, polynomail &Pb);       // 并销毁
void PolySub(polynomail &Pa, polynomail &Pb);       // 并销毁
void PolyMul(polynomail &Pa, polynomail &Pb);      // 并销毁
void PolySub(polynomail &Pa, polynomail &Pb);           // 并销毁


// 算法描述
int cmp(term a, term b);        // 依a的指数值<(或=)（或>）b的指数值，分别返回-1，0，1
void PolybCreate(polynomail &P, int m){
    InitList(P);
    h = GetHead(P);
    e.coef = 0.0;
    e.expn = -1;
    SetCurElem(h, e);       // 设置头结点数据元素
    for (i = 1; i <= m; ++i) {
        scanf(e.coef, e.expn);
        if(!LocateElem(P, e, q, (* cmp)())){    // 当前链表中部存在该指数项
            if (MakeNode(s, e)) InsFirst(q, s); // 生成结点并插入链表
        }
    }
}

void PolyAdd(polynomail &Pa, polynomail &Pb){
    ha = GetHead(Pa);
    hb = GetHead(Pb);       // ha和hb分别指向Pa和Pb的头结点
    qa = NextPos(Pa,ha);
    qb = NextPos(Pbm hb);   // qa和qb分别指向Pa和Pb中当前结点
    while(qa && qb){
        a = GetCurElem(qa);
        b = GetCurElem(qb); // a b 为两表中当前比较元素
        switch(* cmp(a,b)){
            case -1:        // 多项式PA中当前结点的指数小
                ha = qa; qa = NextPos(Pa, qa); break;
            case 0:         // 两者的指数值相等
                sum = a.coef + b.coef;
                if (sum != 0.0) {
                    SetCurElem(qa, sum); ha = qa;
                } else {
                    DelFirst(ha, qa); FreeNode(qa);
                }
                DelFirst(hb, qb);
                FreeNode(qb);
                qb = NextPos(Pb, hb);
                qa = NextPos(Pa, ha);break;
            case 1:
                DelFirst(hb, qb); InsFirst(ha, qb);
                qb = NextPos(Pb, hb); ha = NextPos(Pa, ha);break;
        }
    }

    if (!ListEmpty(Pb)) Append(Pa, qb);
    FreeNode(hb); 

}
```








